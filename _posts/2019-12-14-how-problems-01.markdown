---
layout: post
title:  设计模式
date:   2019-12-14 20:52:12 +08:00
category: 签到系列
tags: 设计模式
comments: true
---

* content
{:toc}


签到1！






## 设计模式六大原则

- 单一职责原则 按照功能划分类，每个类只完成一项任务

- 里氏替换原则 子类不要修改父类的方法

- 最少知道原则 一个对象对依赖的对象知道的越少越好

- 接口隔离原则 一个接口定义的合理化，避免原有接口臃肿

- 开闭原则 对扩展开放对修改关闭

- 依赖倒置原则 高层次的模块尽量不要依赖低模块的功能，底层关注实现高层关注抽象

## 常见设计模式

### 工厂设计模式

- 简单工厂
    一个工厂类创建所有相关的产品，又叫静态工程，如果某个实现要修改需要改工厂类，违反开闭原则
- 工厂方法
    一类工厂统一实现一个接口，每一类工程生产一类对象，每一个工厂针对具体实现，用户调用时只关注那个工厂类即可，把实现延迟到子类工厂的实现中。
- 抽象工厂
    此类工厂的接口的实现比较多，是创建一种品牌的工厂，每个实现工厂具体实现每一种产品，产品品牌化

### 单例设计模式

- 饿汉单例
    系统加载的时候就创建，绝对的线程安全，只有一个问题就是浪费空间；
- 懒汉单例
    系统中具体调用的时候才创建，需要双重校验才能保证线程安全；也可以使用静态内部类实现（完美解决）；
- 注册单例
    把所有实现都缓存到一个容器中，具体使用时再用；
- ThreadLocal
    天然的线程安全；
- 序列化单例
    由于通过序列化存储到文件，再反序列化可以重新破坏单例，所以需要在resovle方法中返回单例对象；

### 原型设计模式

当使用new方法很繁琐的情况下使用：性能由于new,缺点就是需要改造方法和克隆方法；

  - 浅克隆
    问题是引用对象依然指向原来对象
  - 深克隆
    需要使用Cloneable、Serializable接口

### 代理模式

  - 静态代理
   代理对象和被代理对象实现统一接口，代理对象持有接口的引用，当传入被代理对象的引用，调用代理对象的方法后，实现代理
  - 动态代理
    首先获取被代理对象的引用，根据引用获取接口，通过该接口、该引用使用jdk代理创建新的对象引用，把增加的方法通过实现了invocationHandler传进去，再调用该对象，实现动态代理。这个代理类可以是jdk的也可以自定义，都是根据接口创建新的类代码；

### 委派模式

  负责任务的调度和分配任务，跟代理模式很像，可以看做一种特殊的静态代理的全权代理，代理模式关注代理的过程，委派模式关注的结果；如DispatcherServlet

### 策略模式

  定义了算法家族，不会影响算法用户，避免使用过多的if elase

### 模板模式

  定义了一个骨架，允许子类对其进行修改；

### 适配器模式

指将一个借口转换成客户期望的另一个接口，使原本不相关的接口可以实现另外一种目的；提高了类的复用透明，解耦；
但是造成了代码的难于理解；关注功能的兼容和转换

### 装饰者模式

用于扩展一个类的功能或者添加附加职责，动态的添加一些功能；关注功能的覆盖和扩展

### 观察者模式

用于在关联行为之间建立一套触发的机制；
