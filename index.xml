<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>窗外蟋蟀博客</title>
    <link>https://keysaim.github.io/</link>
    <description>Recent content on 窗外蟋蟀博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 21 Mar 2018 13:44:52 +0800</lastBuildDate>
    
        <atom:link href="https://keysaim.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://keysaim.github.io/about/</link>
      <pubDate>Wed, 21 Mar 2018 13:44:52 +0800</pubDate>
      
      <guid>https://keysaim.github.io/about/</guid>
      
        <description>&lt;p&gt;这是一个学习、分享的平台！&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>比较好的学习资料</title>
      <link>https://keysaim.github.io/post/note/awesome-study/</link>
      <pubDate>Fri, 04 May 2018 10:38:05 +0800</pubDate>
      
      <guid>https://keysaim.github.io/post/note/awesome-study/</guid>
      
        <description>

&lt;h1 id=&#34;基础学习&#34;&gt;基础学习&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/xingshaocheng/architect-awesome&#34;&gt;后端架构师技术图谱&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.10tiao.com/html/667/201805/2652080098/1.html&#34;&gt;图解算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>IM系统研究</title>
      <link>https://keysaim.github.io/post/note/im-study/</link>
      <pubDate>Thu, 26 Apr 2018 11:27:05 +0800</pubDate>
      
      <guid>https://keysaim.github.io/post/note/im-study/</guid>
      
        <description>

&lt;h1 id=&#34;原理及架构&#34;&gt;原理及架构&lt;/h1&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yq.aliyun.com/articles/253242&#34;&gt;现代IM系统中消息推送和存储架构的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>消息队列研究</title>
      <link>https://keysaim.github.io/post/note/mq-choose/</link>
      <pubDate>Wed, 25 Apr 2018 13:45:05 +0800</pubDate>
      
      <guid>https://keysaim.github.io/post/note/mq-choose/</guid>
      
        <description>

&lt;h1 id=&#34;rabbitmq&#34;&gt;Rabbitmq&lt;/h1&gt;

&lt;h2 id=&#34;性能限制&#34;&gt;性能限制&lt;/h2&gt;

&lt;p&gt;内部原理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个queue会有一个Erlang协程，每个queue可以处理50K/s的消息&lt;/li&gt;
&lt;li&gt;保持跟CPU Core数量一致的queue数量会带来更好的性能&lt;/li&gt;
&lt;li&gt;每个Client订阅者都至少有一个TCP Connection, 每个Connection消耗至少100KB，最好是确保每个Client只有一条连接，对于不同的queue复用这条连接&lt;/li&gt;
&lt;li&gt;尽量确保Connection keep-alive&lt;/li&gt;
&lt;li&gt;每个TCP Connection也可能产生多个Erlang协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cloudamqp.com/blog/2017-12-29-part1-rabbitmq-best-practice.html&#34;&gt;RabbitMQ Best Practice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rabbitmq.1065348.n5.nabble.com/Max-messages-allowed-in-a-queue-in-RabbitMQ-td26063.html&#34;&gt;Max messages allowed in a queue in RabbitMQ?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/how-many-queues-are-best-max&#34;&gt;How Many Queues Are Best For Max Performance? RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>开源项目整理</title>
      <link>https://keysaim.github.io/post/note/opensource/</link>
      <pubDate>Tue, 24 Apr 2018 13:45:05 +0800</pubDate>
      
      <guid>https://keysaim.github.io/post/note/opensource/</guid>
      
        <description>

&lt;h1 id=&#34;micro-service&#34;&gt;Micro-service&lt;/h1&gt;

&lt;h2 id=&#34;api-gateway&#34;&gt;API Gateway&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kong/kong&#34;&gt;Kong&lt;/a&gt;, in Lua&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/TykTechnologies/tyk&#34;&gt;tyk&lt;/a&gt;, in Golang&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:
* &lt;a href=&#34;https://www.cnblogs.com/savorboard/p/api-gateway.html&#34;&gt;谈谈微服务中的 API 网关（API Gateway）&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;memory-cache&#34;&gt;Memory cache&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/antirez/redis&#34;&gt;Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/siddontang/ledisdb&#34;&gt;ledisdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yongman/tidis&#34;&gt;tidis&lt;/a&gt;, in Golang&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;paas&#34;&gt;PAAS&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes&#34;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/alibaba/pouch&#34;&gt;pouch&lt;/a&gt;, from Alibaba&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;有待观察的&#34;&gt;有待观察的&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/goodrain/rainbond&#34;&gt;rainbond&lt;/a&gt;, 国人开发&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;大数据-ai&#34;&gt;大数据&amp;amp;AI&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/spark&#34;&gt;Spark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ray-project/ray&#34;&gt;Ray&lt;/a&gt;, WIP&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;monitor&#34;&gt;Monitor&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ELK&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;alarms&#34;&gt;Alarms&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/prometheus/prometheus&#34;&gt;Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/MJwJTKXX41Dy-stlVElBDQ&#34;&gt;这里有7种主流案例，告诉你调度器架构设计通用法则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/BoLsVKYyu8yRXZbxd1uuQw&#34;&gt;史上最全Redis高可用技术解决方案大全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;load-balancer&#34;&gt;Load Balancer&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openresty/openresty&#34;&gt;openresty&lt;/a&gt;, 国人开发，Nginx Based&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;nosql&#34;&gt;NoSQL&lt;/h1&gt;

&lt;h2 id=&#34;列存储&#34;&gt;列存储&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scylladb/scylla&#34;&gt;Scylla&lt;/a&gt;, in C++&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/cassandra&#34;&gt;Cassandra&lt;/a&gt;, in Java&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;时序数据库&#34;&gt;时序数据库&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/influxdata/influxdb&#34;&gt;InfluxDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:
* &lt;a href=&#34;https://mp.weixin.qq.com/s/8oxknZqRbeLi4iUlC7lQtg&#34;&gt;时序数据库技术体系 – InfluxDB TSM存储引擎之数据写入&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;benchmark-tools&#34;&gt;Benchmark Tools&lt;/h1&gt;

&lt;h2 id=&#34;dns-performance&#34;&gt;DNS performance&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/turbobytes/dnsperfbench&#34;&gt;dnsperfbench&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;室内定位&#34;&gt;室内定位&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/schollz/find3&#34;&gt;Find3&lt;/a&gt;, High-precision indoor positioning framework&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;异步框架&#34;&gt;异步框架&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scylladb/seastar&#34;&gt;Seastar&lt;/a&gt;, in C++&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>区块链资料整理</title>
      <link>https://keysaim.github.io/post/note/blockchain-marterial/</link>
      <pubDate>Tue, 24 Apr 2018 12:00:05 +0800</pubDate>
      
      <guid>https://keysaim.github.io/post/note/blockchain-marterial/</guid>
      
        <description>

&lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;

&lt;h2 id=&#34;公有链&#34;&gt;公有链&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;以太坊&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;私有链&#34;&gt;私有链&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;R3 Corda&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;联盟链&#34;&gt;联盟链&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hyperledger Fabric&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;References:
* &lt;a href=&#34;http://www.infoq.com/cn/articles/ibm-hyperleger-fabric-achitecture-deployment&#34;&gt;IBM技术专家：Hyperleger Fabric 架构与部署实例解析&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;guide&#34;&gt;Guide&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1ktODJKLMBmkOsi8MPrpIJA&#34;&gt;以太坊官方文档中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1bzAFnzJ35hlQxJ2J4Oj-Ow&#34;&gt;以太坊白皮书中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/18yp9XjEqAHpiFm2ZSCygHw&#34;&gt;Solidity的官方文档中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1y6SVd7lSLUHK21YF5FzIUQ&#34;&gt;Truffle的官方文档中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/13cJxAa80I6iMCczA04CZhg&#34;&gt;区块链技术指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1lz6te3wcQuNJm28rFvBfxg&#34;&gt;精通比特币中文版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;practise&#34;&gt;Practise&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://xc.hubwiz.com/course/5a952991adb3847553d205d1&#34;&gt;一个适合区块链新手的以太坊DApp开发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6&#34;&gt;一个用区块链、星际文件系统（IPFS）、Node.js和MongoDB来构建以太坊DApp电商平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1hOV9hEzi7hFxJCL4LTvC6g&#34;&gt;web3.js API官方文档中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1Ldpn0DvJ5LgLqwix6eWgyg&#34;&gt;Node.js区块链开发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/1M0WxhmumF_fRqzt_cegnag&#34;&gt;geth使用指南文档中文版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pan.baidu.com/s/10qL4q-uKooMehv9X2R1qSA&#34;&gt;以太坊DApp开发环境搭建-Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>SQL Proxy资料整理</title>
      <link>https://keysaim.github.io/post/note/sql-proxy/</link>
      <pubDate>Tue, 17 Apr 2018 16:30:00 +0800</pubDate>
      
      <guid>https://keysaim.github.io/post/note/sql-proxy/</guid>
      
        <description>

&lt;h1 id=&#34;sql-proxy&#34;&gt;SQL Proxy&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.proxysql.com/&#34;&gt;ProxySQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mariadb.com/products/technology/maxscale&#34;&gt;Maxscale&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>WebRTC资料整理</title>
      <link>https://keysaim.github.io/post/note/webrtc-marterial/</link>
      <pubDate>Thu, 12 Apr 2018 20:00:00 +0800</pubDate>
      
      <guid>https://keysaim.github.io/post/note/webrtc-marterial/</guid>
      
        <description>

&lt;h1 id=&#34;参考文章&#34;&gt;参考文章&lt;/h1&gt;

&lt;h2 id=&#34;技术简介&#34;&gt;技术简介&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.miit.gov.cn/n1146312/n1146909/n1146991/n1648534/c3489337/content.html&#34;&gt;Web Real-Time Communication（WebRTC）技术概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.wilddog.com/?p=2196&#34;&gt;WebRTC 是如何进行通信的，WebRCT 的三种网络结构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;互动直播&#34;&gt;互动直播&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/zhangxiaoliu/archive/2017/03/20/6586575.html&#34;&gt;互动直播的技术细节和解决方案实践经验谈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;流程分析&#34;&gt;流程分析&lt;/h2&gt;

&lt;h3 id=&#34;信令流程&#34;&gt;信令流程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.wilddog.com/?p=2206&#34;&gt;WebRTC 信令交互流程&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;align: center&#34;&gt;
    &lt;img src=&#34;https://blog.wilddog.com/wp-content/uploads/2017/09/webrtc.png&#34;/&gt;
&lt;/div&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/key1213/article/details/52441103&#34;&gt;WebRTC + 直播 + 连麦 = AnyRTC&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;质量控制&#34;&gt;质量控制&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.callstats.io/2015/07/06/basics-webrtc-getstats-api/&#34;&gt;Basics of WebRTC getStats() API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;上手&#34;&gt;上手&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.scaledrone.com/blog/posts/webrtc-tutorial-simple-video-chat&#34;&gt;WebRTC Tutorial: Simple video chat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codelabs.developers.google.com/codelabs/webrtc-web/#0&#34;&gt;WebRTC codelab&lt;/a&gt;, the old version is &lt;a href=&#34;https://bitbucket.org/webrtc/codelab&#34;&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/webrtc/index.htm&#34;&gt;WebRTC Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.html5rocks.com/en/tutorials/webrtc/basics/&#34;&gt;Getting started with WebRTC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.html5rocks.com/en/tutorials/getusermedia/intro/&#34;&gt;Capturing Audio &amp;amp; Video in HTML5&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://blog.coding.net/blog/getting-started-with-webrtc&#34;&gt;WebRTC 的前世今生&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://io13webrtc.appspot.com/#1&#34;&gt;WebRTC ppt&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;guide&#34;&gt;Guide&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.agora.io/cn/blog/courses-webrtc/&#34;&gt;从事WebRTC之前必读的一些教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;开发资讯&#34;&gt;开发资讯&lt;/h2&gt;

&lt;h3 id=&#34;互动直播整体方案&#34;&gt;互动直播整体方案&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://netease.im/dev-blog&#34;&gt;网易云博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/s/results/?q=webrtc&amp;amp;p=%2Fweb%2F&#34;&gt;Google developers updates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;webrtc&#34;&gt;WebRTC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.agora.io/cn/blog/category/webrtc/&#34;&gt;agora.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;书籍&#34;&gt;书籍&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.webrtcbook.com/&#34;&gt;WebRTC APIs and RTCWEB Protocols of the HTML5 Real-Time Web&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;视频&#34;&gt;视频&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=E8C8ouiXHHk&#34;&gt;Google I/O presentation video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vimeo.com/47682405&#34;&gt;RTCWeb Explained&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;网站&#34;&gt;网站&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://webrtc.org.cn/&#34;&gt;webrtc.org.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://io13webrtc.appspot.com/webrtc.org&#34;&gt;webrtc.org&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;社区&#34;&gt;社区&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/?fromgroups#!forum/discuss-webrtc&#34;&gt;discuss-webrtc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://plus.sandbox.google.com/113817074606039822053/posts&#34;&gt;+webrtc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/webrtc&#34;&gt;@webrtc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.crbug.com/new&#34;&gt;crbug.com/new&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://io13webrtc.appspot.com&#34;&gt;io13webrtc.appspot.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;开源项目&#34;&gt;开源项目&lt;/h1&gt;

&lt;h2 id=&#34;stun-turn&#34;&gt;STUN/TURN&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/coturn/coturn&#34;&gt;coturn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This project evolved from rfc5766-turn-server project.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.creytiv.com/restund.html&#34;&gt;restund&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;media-server&#34;&gt;Media Server&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SFU (Selective Forwarding Unit)&lt;/li&gt;
&lt;li&gt;MCU (Multipoint Control Unit)&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;server&lt;/th&gt;
&lt;th&gt;SFU&lt;/th&gt;
&lt;th&gt;MCU&lt;/th&gt;
&lt;th&gt;recording&lt;/th&gt;
&lt;th&gt;lang&lt;/th&gt;
&lt;th&gt;OSS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Janus&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/meetecho/janus-gateway&#34;&gt;github&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Jitsi&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/jitsi/jitsi-videobridge&#34;&gt;github&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Kurento&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/Kurento/kurento-media-server&#34;&gt;github&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Licode&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;C++&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/lynckia/licode&#34;&gt;github&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;非开源的有：
&lt;a href=&#34;http://www.tokbox.com/blog/mantis-next-generation-cloud-technology-for-webrtc/&#34;&gt;Mantis&lt;/a&gt;, &lt;a href=&#34;https://software.intel.com/en-us/webrtc-sdk&#34;&gt;Intel Collaboration Suite for WebRTC&lt;/a&gt;(Licode based)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于各种Media Server比较的文章：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://webrtcbydralex.com/index.php/2016/12/13/overview-of-webrtc-media-servers/&#34;&gt;Overview of WebRTC Media Servers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;美颜&#34;&gt;美颜&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/BradLarson/GPUImage&#34;&gt;GPUImage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Python学习推荐书籍</title>
      <link>https://keysaim.github.io/post/note/learn-python-books/</link>
      <pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/note/learn-python-books/</guid>
      
        <description>

&lt;h1 id=&#34;入门&#34;&gt;入门&lt;/h1&gt;

&lt;h1 id=&#34;进阶&#34;&gt;进阶&lt;/h1&gt;

&lt;h2 id=&#34;fluent-python&#34;&gt;Fluent Python&lt;/h2&gt;

&lt;p&gt;这本书是由奋战在Python开发一线近20年的Luciano Ramalho执笔，致力于帮助Python开发人员挖掘这门语言及相关程序库的优秀特性，写出简洁、流畅、易读、易维护的代码。书中从语言设计层面剖析编程细节，兼顾Python 3 和Python 2，同时有大量详尽的代码示例，并附有主题相关高质量的参考文献和视频链接。&lt;/p&gt;

&lt;p&gt;书籍简介参考&lt;a href=&#34;http://shop.oreilly.com/product/0636920032519.do&#34;&gt;这里&lt;/a&gt;，可以在&lt;a href=&#34;http://www.foxebook.net/fluent-python/&#34;&gt;这里&lt;/a&gt;免费下载。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何在github.io搭建Hugo博客站</title>
      <link>https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/</guid>
      
        <description>

&lt;h1 id=&#34;摘要&#34;&gt;摘要&lt;/h1&gt;

&lt;p&gt;在&lt;a href=&#34;Jekyll blog&#34;&gt;前面的博文&lt;/a&gt;中介绍了如何在&lt;code&gt;github.io&lt;/code&gt;上搭建自己的博客站，基于的是&lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;，这也是github中比较常用的方式，好处是github可以自动调用&lt;code&gt;Jekyll&lt;/code&gt;来帮你及时生成、更新你的博客站。本来一切还是挺美好的，随着使用的深入，博主发现有几点实在是不能忍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;github上面的&lt;code&gt;Jekyll&lt;/code&gt;版本实在太低了，对于code block渲染问题严重。最受不了的一点就是很多种类型的code在里面被显示成一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jekyll&lt;/code&gt;对文章的文件名有着严格的定义，且不能够放到不同的目录，这个在博文比较多的时候极为不便&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;博主平时喜欢关注各种新技术，较早的时候就曾关注过一个的博客建站的工具&lt;code&gt;Hugo&lt;/code&gt;，用Go语言（博主的最爱之一）写的，当时就觉得挺不错。经过这几年的发展已经非常成熟，Github上面的Stars截止本文已经24250了。在经过一段时间的&lt;code&gt;Jekyll&lt;/code&gt;的折磨之后，终于乘着最近稍微闲了一点，将&lt;code&gt;Jekyll&lt;/code&gt;彻底换成了&lt;code&gt;Hugo&lt;/code&gt;。本文就简单介绍一下，如何在github.io上部署你的&lt;code&gt;Hugo&lt;/code&gt;博客站。&lt;/p&gt;

&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;

&lt;p&gt;跟基于&lt;code&gt;Jekyll&lt;/code&gt;一样，如果需要在github.io上部署的话，必须在github上创建你自己的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;的repo，详细过程请参见&lt;a href=&#34;Jekyll blog&#34;&gt;前面的博文&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;搭建-hugo-博客站&#34;&gt;搭建&lt;code&gt;Hugo&lt;/code&gt;博客站&lt;/h1&gt;

&lt;h2 id=&#34;安装-hugo&#34;&gt;安装&lt;code&gt;Hugo&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;的安装非常简单，在MAC上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```sh
brew install hugo
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它安装方式，可以参见&lt;a href=&#34;https://gohugo.io/getting-started/installing/&#34;&gt;官网教程&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;创建你的博客站&#34;&gt;创建你的博客站&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在github上面创建博客文章的repo&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;的建站部署方式跟&lt;code&gt;Jekyll&lt;/code&gt;不同，github会自动的识别&lt;code&gt;Jekyll&lt;/code&gt;并调用&lt;code&gt;Jekyll&lt;/code&gt;工具帮你自动生成、更新博客站，所以我们只需要直接在自己的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;中编写文章并上传即可。但是github并不能直接识别&lt;code&gt;Hugo&lt;/code&gt;的内容，因此，这个博客站的生成、更新的工作得由你自己完成，&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;只是用来托管你生成后的静态网站的内容（github支持托管静态网站，请参见&lt;a href=&#34;https://help.github.com/articles/user-organization-and-project-pages/#user--organization-pages&#34;&gt;这里&lt;/a&gt;)，因此，你还需要另一个git repo来真正的编辑、保存、管理你的博文。为此，博主创建了一个名为&lt;a href=&#34;https://github.com/keysaim/blogs&#34;&gt;blogs&lt;/a&gt;的repo，以下说到博文管理repo指的就是这个repo。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用&lt;code&gt;Hugo&lt;/code&gt;建站&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化博客站&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hugo new site blogs
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git init&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd blogs
git init
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指定github源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote add origin git@github.com:keysaim/blogs.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样，你本地的初始化的&lt;code&gt;Hugo&lt;/code&gt;博客站已经准备好了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加一个主题&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;官方有非常多的免费开源的主题，&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;猛击这里&lt;/a&gt;。博主选用的是国人开发的一款主题&lt;a href=&#34;https://themes.gohugo.io/hugo-theme-jane/&#34;&gt;Jane&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git submodule add -b master https://github.com/xianmin/hugo-theme-jane.git themes/jane
cp -r themes/jane/exampleSite/content ./
cp themes/jane/exampleSite/config.toml ./
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地测试&lt;/p&gt;

&lt;p&gt;在部署之前，先本地测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后本地浏览器打开&lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;，没有意外的话你将看到类似这样的：&lt;/p&gt;

&lt;div style=&#34;text-align:center&#34;&gt;
    &lt;img src=&#34;https://d33wubrfki0l68.cloudfront.net/9a581e943c0732d9c9852138ff0ad94f10b710a8/b6bf8/hugo-theme-jane/hugo-theme-jane/screenshot-hugo-theme-jane_huda38615ea8fd917fd31d36ba7a275d34_226834_1500x1000_fill_catmullrom_top_2.png&#34; alt=&#34;&#34; width=&#34;100%&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;这是&lt;code&gt;Jane&lt;/code&gt;主题默认提供的样式跟内容，说明你的本地&lt;code&gt;Hugo&lt;/code&gt;站可以正常工作了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;修改默认的配置&#34;&gt;修改默认的配置&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Hugo&lt;/code&gt;的默认配置文件是&lt;code&gt;config.toml&lt;/code&gt;，这里还是&lt;code&gt;Jane&lt;/code&gt;提供的默认配置，需要修改为你自己的信息，比如名字等，很多配置显而易见，这里不详述，只是着重指出几个有点困难或者比较重要的配置：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;baseURL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;baseURL&lt;/code&gt;是你博客最终部署的网站的url，基于github.io的话就应该是这样的&lt;a href=&#34;https://keysaim.github.io/&#34;&gt;https://keysaim.github.io/&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启用gitment&lt;/p&gt;

&lt;p&gt;关于gitment的详细教程，请参见&lt;a href=&#34;https://keysaim.github.io/post/2017-08-16-how-to-add-comments/&#34;&gt;这篇博文&lt;/a&gt;，按照教程准备好github的几个token之后，只需要修改&lt;code&gt;Hugo&lt;/code&gt;配置中的这几行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[params.gitment]          # Gitment is a comment system based on GitHub issues. see https://github.com/imsun/gitment
    owner = &amp;quot;keysaim&amp;quot;              # Your GitHub ID
    repo = &amp;quot;comments&amp;quot;               # The repo to store comments
    clientId = &amp;quot;xxxx&amp;quot;           # Your client ID
    clientSecret = &amp;quot;xxxx&amp;quot;       # Your client secret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，repo就是教程中所说的github上面为保存comments而创建的repo，clientId跟clientSecret就是你自己创建的oauth授权信息。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改页面博文数量显示&lt;/p&gt;

&lt;p&gt;有几个参数会影响页面博文数的显示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;paginate = 15               # 首页每页显示的文章数
archive-paginate = 50       # 归档、标签、分类每页显示的文章数目
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改语言&lt;/p&gt;

&lt;p&gt;如果你需要将博客站显示成中文，那么请这么修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;defaultContentLanguage = &amp;quot;zh-cn&amp;quot;
[Languages.zh-cn]
  languageCode = &amp;quot;zh-cn&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;编辑博文&#34;&gt;编辑博文&lt;/h2&gt;

&lt;p&gt;默认情况下，&lt;code&gt;Jane&lt;/code&gt;主题将博文放在&lt;code&gt;content/post/&lt;/code&gt;下面，你需要在这下面编辑你的博文。&lt;code&gt;Hugo&lt;/code&gt;是支持分目录的，这点非常好，比如博主可以这么分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ll
total 4
drwxr-xr-x 3 nbaoping staff  102 Mar 21 16:22 arch
drwxr-xr-x 6 nbaoping staff  204 Mar 22 10:50 blog
drwxr-xr-x 5 nbaoping staff  170 Mar 22 10:33 docker
drwxr-xr-x 4 nbaoping staff  136 Mar 21 16:21 git
drwxr-xr-x 9 nbaoping staff  306 Mar 21 16:20 linux
drwxr-xr-x 3 nbaoping staff  102 Mar 21 16:22 note
drwxr-xr-x 3 nbaoping staff  102 Mar 21 16:24 others
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一点非常不错的就是&lt;code&gt;Hugo&lt;/code&gt;可以识别出&lt;code&gt;Jekyll&lt;/code&gt;的博文，包括里面的标题，时间跟标签等信息。这样博主非常方便的将之前的&lt;code&gt;Jekyll&lt;/code&gt;的所有博文直接迁移过来了，而无需做什么修改。当然，如果你新写博文的话，在博文的头部可以这样编写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
date: 2018-03-22
title: &amp;quot;如何在github.io搭建Hugo博客&amp;quot;
tags:
    - 教程
    - github
categories:
    - github
comment: true
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写完成之后，本地查看一下你的博文，没有问题的话先提交到你的博文管理的repo：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git add xxxx
git commit -m &amp;quot;YOUR COMMIT MESSAGE&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;部署博客站&#34;&gt;部署博客站&lt;/h2&gt;

&lt;p&gt;这一步很关键了，咱们需要将自己的&lt;code&gt;Hugo&lt;/code&gt;博文站部署到github.io。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加你的github.io&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git submodule add -b master git@github.com:keysaim/keysaim.github.io.git public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里将其作为submodule添加进来，且放到&lt;code&gt;public&lt;/code&gt;目录下面，&lt;code&gt;public&lt;/code&gt;目录是&lt;code&gt;Hugo&lt;/code&gt;生成静态文件的地方，这样的话咱们就可以把生成出来的静态文件直接上传到你的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;的repo里面了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成静态博客站&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接运行&lt;code&gt;hugo&lt;/code&gt;命令，就会在&lt;code&gt;public&lt;/code&gt;目录下生成静态博客站。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd public
git add .
git commit -m &amp;quot;YOUR COMMIT MESSAGE&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看你的github.io博客站&lt;/p&gt;

&lt;p&gt;正常情况下，过一会你就可以看到你基于&lt;code&gt;Hugo&lt;/code&gt;的github.io博客站了，博主的是&lt;a href=&#34;https://keysaim.github.io/&#34;&gt;https://keysaim.github.io/&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;自动部署脚本&#34;&gt;自动部署脚本&lt;/h2&gt;

&lt;p&gt;为了方便，&lt;code&gt;Hugo&lt;/code&gt;提供了一个&lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/#put-it-into-a-script&#34;&gt;自动部署的脚本&lt;/a&gt;，这里博主稍微修改了一点点用来同时提交这两个repo：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

if [ $# -lt  1 ]; then
    echo &amp;quot;$0 &amp;lt;commit message&amp;gt;&amp;quot;
    exit 1
fi

msg=&amp;quot;$1&amp;quot;
git commit -m &amp;quot;$msg&amp;quot;
if [ $? -ne 0 ]; then
    echo &amp;quot;Commit failed&amp;quot;
    exit 1
fi
git push origin master
if [ $? -ne 0 ]; then
    echo &amp;quot;Push failed&amp;quot;
fi

echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;

# Build the project.
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`

# Go To Public folder
cd public
# Add changes to git.
git add .

# Commit changes.
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master

# Come Back up to the Project Root
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，恭喜你已经完成了你的&lt;code&gt;Hugo&lt;/code&gt;博客站了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（五）常用命令</title>
      <link>https://keysaim.github.io/post/linux/2017-11-17-linux-study-common-tools/</link>
      <pubDate>Fri, 17 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-11-17-linux-study-common-tools/</guid>
      
        <description>

&lt;h1 id=&#34;cat命令&#34;&gt;cat命令&lt;/h1&gt;

&lt;p&gt;很多时候我们通过&lt;code&gt;cat&lt;/code&gt;命令来查看文件内容，它会将文件的所有内容显示出来。当然，&lt;code&gt;cat&lt;/code&gt;也可以通过管道接收数据，它主要完成的是将从管道接收的输入导到输出。&lt;/p&gt;

&lt;h1 id=&#34;more跟less命令&#34;&gt;more跟less命令&lt;/h1&gt;

&lt;p&gt;有时候用&lt;code&gt;cat&lt;/code&gt;命令来显示一个较大的文件并不方便，整个文件内容一次性显示出来简直就是刷屏了。如果需要一页页的显示内容，可以使用&lt;code&gt;more&lt;/code&gt;或者&lt;code&gt;less&lt;/code&gt;命令，这两个命令会以分页的形式显示文件内容，至于使用哪个命令完全看个人习惯了。此外，这两个命令不仅可以分页显示，而且在分页模式下，你可以用快捷键方便的浏览及搜索：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 按`d`下翻页
* 按空格下翻页
* 按回车下移一行
* 按`/`进入搜索模式，输入要搜索的关键字，按回车搜索。
* 按`n`搜索下一个
* 按`q`退出查看
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tee命令&#34;&gt;tee命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令一般从管道接收数据，这点与&lt;code&gt;cat&lt;/code&gt;类似，将stdin导到stdout。不同的是，&lt;code&gt;tee&lt;/code&gt;同时还可以指定一个文件作为输出。这点非常有用，有时候我们想一般看到命令的输出，同时又希望将输出保存到文件中，这时候用&lt;code&gt;tee&lt;/code&gt;最为合适。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date | tee time.log
Mon Nov 20 14:05:02 EST 2017
# cat time.log
Mon Nov 20 14:05:02 EST 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;date命令&#34;&gt;date命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令用来显示时间跟时区，比较常见的用法有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认显示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date
Sun Nov 19 20:08:21 EST 2017
# date -u
Mon Nov 20 01:08:28 UTC 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;-u&lt;/code&gt;参数表示显示UTC标准时间，即时区为0的时间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指定显示格式&lt;/p&gt;

&lt;p&gt;除了默认输出，我们也可以指定显示的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date +&#39;%A %d-%m-%Y UTC %:z&#39;
Sunday 19-11-2017 UTC -05:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;date&lt;/code&gt;支持非常多元化的格式，具体可以参考&lt;a href=&#34;https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示当前时间的秒数&lt;/p&gt;

&lt;p&gt;通常，在计算当前时间的秒数的时候，我们通常会以&lt;a href=&#34;https://en.wikipedia.org/wiki/Unix_time&#34;&gt;Unix Epoch Time&lt;/a&gt;为基准，用&lt;code&gt;date&lt;/code&gt;命令可以非常方便的显示当前时间的秒数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date +%s
1511141040
# date +%s --date=&#39;2017/11/19 09:56:00&#39;
1511103360
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，也可以通过参数&lt;code&gt;--date&lt;/code&gt;指定时间来计算。反过来，如果我们知道了时间的秒数，需要显示其相对于Unix Epoch Time的时间，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date; date +%s
Mon Nov 20 10:33:07 EST 2017
1511191987
# date --date=@1511191987
Mon Nov 20 10:33:07 EST 2017
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;时间偏移计算&lt;/p&gt;

&lt;p&gt;有时候需要知道多少天前是什么时间，这时候需要用到时间偏移计算了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date --date=&#39;100 seconds ago&#39;
Sun Nov 19 20:35:44 EST 2017
# date --date=&#39;100 hours ago&#39;
Wed Nov 15 16:37:28 EST 2017
# date --date=&#39;100 days ago&#39;
Fri Aug 11 21:37:34 EDT 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;date&lt;/code&gt;命令可以识别多种时间偏移写法，除了示例中的，还有&lt;code&gt;minutes months years&lt;/code&gt;等，当然，也可以这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date --date=&#39;+ 1000 seconds&#39;
Sun Nov 19 20:56:28 EST 2017
# date --date=&#39;- 1000 seconds&#39;
Sun Nov 19 20:23:41 EST 2017
# date --date=&#39;2017-11-19 00:00:00 + 1000 seconds&#39;
Sat Nov 18 09:00:01 EST 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接用&lt;code&gt;+&lt;/code&gt;或者&lt;code&gt;-&lt;/code&gt;表示以后或者以前的时间，也可以指定某个时间点然后偏移。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置时间&lt;/p&gt;

&lt;p&gt;当然，你也可以通过&lt;code&gt;date&lt;/code&gt;命令来设置时间：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date
Sun Nov 19 20:44:11 EST 2017
# date --set=&#39;Sun Nov 19 20:44:30 EST 2017&#39;
Sun Nov 19 20:44:30 EST 2017
# date
Sun Nov 19 20:44:31 EST 2017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;--set&lt;/code&gt;也可以简写为&lt;code&gt;-s&lt;/code&gt;，时间格式非常灵活：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date -s &#39;2017/11/20 10:19:50&#39;
Mon Nov 20 10:19:50 EST 2017
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cal命令&#34;&gt;cal命令&lt;/h1&gt;

&lt;p&gt;我们用&lt;code&gt;date&lt;/code&gt;可以显示时间，同时咱们还可以通过&lt;code&gt;cal&lt;/code&gt;命令来显示日历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cal
    November 2017
Su Mo Tu We Th Fr Sa
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以指定要显示的日期，比如1949年10月的日历：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cal 10 1949
    October 1949
Su Mo Tu We Th Fr Sa
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30 31
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;time命令&#34;&gt;time命令&lt;/h1&gt;

&lt;p&gt;有时候我们需要知道一个命令运行了多少时间，这时候我们可以用&lt;code&gt;time&lt;/code&gt;命令来计时：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# time sleep 1

real	0m1.018s
user	0m0.001s
sys  	0m0.002s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;sleep 1&lt;/code&gt;用来睡眠1秒，&lt;code&gt;real&lt;/code&gt;表示实际用了多少时间，&lt;code&gt;user&lt;/code&gt;表示在用户态花了多少时间，&lt;code&gt;sys&lt;/code&gt;则表示在内核花了多少时间。详细可以参考&lt;a href=&#34;https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1&#34;&gt;这篇问答&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;wc命令&#34;&gt;wc命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;wc&lt;/code&gt;命令是&lt;code&gt;Word Count&lt;/code&gt;的简称，顾名思义就是用来统计单词的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | wc -w
14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数&lt;code&gt;-w&lt;/code&gt;表示统计单词数，这里的单词实际上指的是被空格分开的字符串。下面列举出&lt;code&gt;wc&lt;/code&gt;命令的有关参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;统计多少单词&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;统计多少行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;统计有多少个字节&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;统计有多少个字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-L&lt;/td&gt;
&lt;td&gt;统计长度最长的行的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注意，这里的字节跟字符的差别，在英文中基本上是一样的，但是在多字节语言中，其意义就不一样了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &#39;你好&#39; | wc -c
7
# echo &#39;你好&#39; | wc -m
3
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;find命令&#34;&gt;find命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt;命令用来查找文件或目录，这又是一个非常强大的且常用的命令，这里只介绍几种常见的用法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据名字查找&lt;/p&gt;

&lt;p&gt;这是基本且常见的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -name &amp;quot;test*&amp;quot;
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例中表示在当前目录（用&lt;code&gt;.&lt;/code&gt;表示）下包括其子目录，查找文件名以&lt;code&gt;test&lt;/code&gt;开头的文件或者目录。默认情况下，&lt;code&gt;find&lt;/code&gt;命令是大小写敏感的，如果需要忽略大小写，则可以改用参数&lt;code&gt;-iname&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据路径查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-name&lt;/code&gt;参数会根据名字查找，如果需要对路径进行匹配查找，则可以用&lt;code&gt;-path&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -path &amp;quot;./tmp/*&amp;quot;
./tmp/Test1
./tmp/test2
./tmp/test.log
./tmp/test.cpp
./tmp/time.log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据类型查找&lt;/p&gt;

&lt;p&gt;可以根据类型查找文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -type f
./Test1
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以同时根据类型跟文件名一起查找：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# find . -type f -name &amp;quot;test*&amp;quot;
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;f&lt;/code&gt;表示文件，如果是查找目录的话则用&lt;code&gt;d&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据时间查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt;命令还可以根据时间来查找文件目录，其中一个用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . -newer base_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示在当前目录下查找比&lt;code&gt;base_file&lt;/code&gt;文件更新的文件或者目录。此外，&lt;code&gt;find&lt;/code&gt;还可以根据文件的&lt;a href=&#34;https://www.unixtutorial.org/2008/04/atime-ctime-mtime-in-unix-filesystems/&#34;&gt;atime, ctime, mtime&lt;/a&gt;来查找文件，如下，根据修改时间来查找：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# date
Fri Nov 17 20:34:52 EST 2017
# ll
total 20
drwxr-xr-x.  2 root root   45 Nov 17 02:46 ./
dr-xr-x---. 48 root root 8192 Nov 17 02:46 ../
-rw-r--r--.  1 root root    0 Nov 16 00:17 Test1
-rw-r--r--.  1 root root   34 Nov 17 02:46 test2
-rw-r--r--.  1 root root  102 Nov 17 00:30 test.log
# find . -mtime -1
.
./test.log
./test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-mtime&lt;/code&gt;表示根据修改时间查找，&lt;code&gt;-1&lt;/code&gt;表示最近一天。&lt;code&gt;find&lt;/code&gt;支持的时间查找总结如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-mtime&lt;/td&gt;
&lt;td&gt;根据修改时间，也就是&lt;code&gt;ls -l&lt;/code&gt;显示的时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-atime&lt;/td&gt;
&lt;td&gt;根据访问时间，也就是&lt;code&gt;ls -lu&lt;/code&gt;显示的时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-ctime&lt;/td&gt;
&lt;td&gt;根据状态改变的时间，也就是&lt;code&gt;ls -lc&lt;/code&gt;显示的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;时间值的表示说明：基准&lt;code&gt;+0&lt;/code&gt;表示一天前，&lt;code&gt;-1.5&lt;/code&gt;表示最近1.5天，&lt;code&gt;+1.5&lt;/code&gt;表示2.5天前&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逻辑查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt;支持与或非逻辑的查找，比如查找所有C++的源文件，实际上需要找出后缀为&lt;code&gt;.cpp&lt;/code&gt;跟&lt;code&gt;.h&lt;/code&gt;的文件，需要用到&lt;code&gt;find&lt;/code&gt;的逻辑或的查找：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-o&lt;/code&gt;是&lt;code&gt;-or&lt;/code&gt;的缩写，用来表示逻辑或的关系，而&lt;code&gt;-name &amp;quot;*.cpp&amp;quot;&lt;/code&gt;与&lt;code&gt;-name &amp;quot;*.h&amp;quot;&lt;/code&gt;为表达式，构成了&lt;code&gt;EXP1 or EXP2&lt;/code&gt;的关系，只要文件或者目录满足其中一个表达式就会输出。&lt;code&gt;find&lt;/code&gt;支持的逻辑关系如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;逻辑&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;与&lt;/td&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-and&lt;/code&gt;的缩写，逻辑与的关系，如&lt;code&gt;find . -type f -a -name &amp;quot;*.log&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;或&lt;/td&gt;
&lt;td&gt;-o&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-or&lt;/code&gt;的缩写，逻辑或的关系, 如&lt;code&gt;find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;非&lt;/td&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-not&lt;/code&gt;的缩写，逻辑非的关系, 如&lt;code&gt;find . ! -name &amp;quot;*.cpp&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，&lt;code&gt;find&lt;/code&gt;命令还有一个非常重要且常见的用法，就是在找到文件后执行某个命令，改用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -name &amp;quot;*.log&amp;quot; -exec rm {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示删除当前目录包括子目录中以&lt;code&gt;.log&lt;/code&gt;为后缀的所有文件。其中，&lt;code&gt;-exec&lt;/code&gt;表示在找到后需要执行命令，而命令为&lt;code&gt;rm {} \;&lt;/code&gt;，实际上此命令就是一般的&lt;code&gt;shell&lt;/code&gt;命令，其中&lt;code&gt;{}&lt;/code&gt;用来指代找到的文件或目录，这里&lt;code&gt;;&lt;/code&gt;必须转义，因为需要传递给&lt;code&gt;find&lt;/code&gt;本身，如果不转义，则会直接被&lt;code&gt;shell&lt;/code&gt;解析使用了。每找到一个文件或目录，都会执行指定的命令，其中&lt;code&gt;{}&lt;/code&gt;部分以文件路径替代。如果需要只执行一次命令，而把所有找到的文件作为参数传递给该命令，则需要用&lt;code&gt;+&lt;/code&gt;替代&lt;code&gt;\;&lt;/code&gt;，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -name &amp;quot;*.log&amp;quot; -exec rm {} +
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定找到的文件有&lt;code&gt;test.log&lt;/code&gt;，&lt;code&gt;test1.log&lt;/code&gt;，用&lt;code&gt;\;&lt;/code&gt;的方式相当于执行两次：&lt;code&gt;rm test.log&lt;/code&gt;跟&lt;code&gt;rm test1.log&lt;/code&gt;；如果使用&lt;code&gt;+&lt;/code&gt;则只有一次命令&lt;code&gt;rm test.log test1.log&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;sort命令&#34;&gt;sort命令&lt;/h1&gt;

&lt;p&gt;顾名思义，这个命令就是用来排序的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd | sort
adm❌3:4:adm:/var/adm:/sbin/nologin
bin❌1:1:bin:/bin:/sbin/nologin
daemon❌2:2:daemon:/sbin:/sbin/nologin
lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
root❌0:0:root:/root:/bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，&lt;code&gt;sort&lt;/code&gt;命令以字典顺序对每行进行排序，如果不带参数，会将整行作为一个字符串进行比较。当然，你也可以指定以第几列进行排序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd | tr : &amp;quot; &amp;quot; | sort -k 3
root x 0 0 root /root /bin/bash
bin x 1 1 bin /bin /sbin/nologin
daemon x 2 2 daemon /sbin /sbin/nologin
adm x 3 4 adm /var/adm /sbin/nologin
lp x 4 7 lp /var/spool/lpd /sbin/nologin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里先将&lt;code&gt;:&lt;/code&gt;换成空格（关于&lt;code&gt;tr&lt;/code&gt;命令，请参照本文关于&lt;code&gt;tr&lt;/code&gt;命令的章节），然后以&lt;code&gt;-k&lt;/code&gt;为参数，指定以第三列进行排序。下面列举其常用的一些参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;以第几列排序，列以空格为分隔&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;默认&lt;code&gt;sort&lt;/code&gt;以升序输出，&lt;code&gt;-r&lt;/code&gt;参数则可以以降序输出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;在指定第几列的时候，可以强制&lt;code&gt;sort&lt;/code&gt;把列的值以数字值进行排序，如下面的例子&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;默认情况下认为列是以空格为分隔，&lt;code&gt;-t&lt;/code&gt;参数则可以指定分隔符，这样，上面的例子其实可以直接写成&lt;code&gt;sort -t : -k 3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;忽略大小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;如果排序后出现重复的行，加上这个参数将只显示一行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2
10
3
5
3
# cat test2 | sort
10
3
3
5
# cat test2 | sort -n
3
3
5
10
# cat test2 | sort -n -u
3
5
10
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;uniq命令&#34;&gt;uniq命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;uniq&lt;/code&gt;是&lt;code&gt;unique&lt;/code&gt;的简写，用来消除&lt;code&gt;sort&lt;/code&gt;排序后重复的行，即相当于&lt;code&gt;sort&lt;/code&gt;命令中的&lt;code&gt;-u&lt;/code&gt;参数。但是，&lt;code&gt;uniq&lt;/code&gt;不仅可以消除重复行，它还可以显示分别重复了多少行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2 | sort -n | uniq -c
      2 3
      1 5
      1 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有些常用的参数如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;忽略大小写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;只打印有重复的行，每组一个，如果要打印组内所有的，则用&lt;code&gt;-D&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;只打印没有重复的行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;比较的时候，忽略前面的N列&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;比较的时候，忽略前面的N个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;od命令&#34;&gt;od命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;od&lt;/code&gt;可以用来显示二进制文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2
abcdefg
1234567
# od -t x1 test2
0000000 61 62 63 64 65 66 67 0a 31 32 33 34 35 36 37 0a
0000020
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，也可以直接显示字符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# od -c test2
0000000   a   b   c   d   e   f   g  \n   1   2   3   4   5   6   7  \n
0000020
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，如果仅仅只是显示二进制内容，还可以使用&lt;code&gt;hexdump&lt;/code&gt;命令了。&lt;/p&gt;

&lt;h1 id=&#34;压缩类命令&#34;&gt;压缩类命令&lt;/h1&gt;

&lt;h2 id=&#34;tar命令&#34;&gt;tar命令&lt;/h2&gt;

&lt;p&gt;在Linux中，用的最多的压缩命令就是&lt;code&gt;tar&lt;/code&gt;命令了，在介绍其用法之前，需要清楚几个概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;存档文件(Archive File)&lt;/p&gt;

&lt;p&gt;存档文件用来打包多个文件成一个文件，以方便在网络上传输。请注意，打包成的文件并没有被压缩。在Linux或Unix系统中，TAR文件是最为常用的存档文件（通常以&lt;code&gt;.tar&lt;/code&gt;为文件后缀）。TAR文件的更多解释可以参考&lt;a href=&#34;http://www.bitzipper.com/tar-file.html&#34;&gt;这里&lt;/a&gt;。用&lt;code&gt;tar&lt;/code&gt;命令可以生产TAR文件，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar cvf tmp.tar tmp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体参数在下面会具体解释，不带任何压缩格式的话，&lt;code&gt;tar&lt;/code&gt;命令会生成一个TAR文件。相应的，如果需要解开TAR文件，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar xvf tmp.tar
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;压缩文件(Compressed File)&lt;/p&gt;

&lt;p&gt;TAR文件是没有被压缩的，大小基本保持不变。如果需要对文件进行压缩，则需要在&lt;code&gt;tar&lt;/code&gt;命令中加入压缩格式对应的参数，具体在下面会说明。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面来详细介绍&lt;code&gt;tar&lt;/code&gt;命令的用法，&lt;code&gt;tar&lt;/code&gt;的用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar --help
Usage: tar [OPTION...] [FILE]...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tar&lt;/code&gt;命令支持非常多的参数，这里列举比较常用的几种使用方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;压缩文件或目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar czvf tmp.tgz tmp/
tmp/
tmp/Test1
tmp/test.log
tmp/test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;czvf&lt;/code&gt;表示参数选项；&lt;code&gt;tmp.tgz&lt;/code&gt;表示压缩后的文件名，通常&lt;code&gt;tgz&lt;/code&gt;是&lt;code&gt;tar.gz&lt;/code&gt;的简写；&lt;code&gt;tmp/&lt;/code&gt;表示被压缩的目录。参数的解释如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Create&lt;/code&gt;的简写，表示生产压缩文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;z&lt;/td&gt;
&lt;td&gt;表示采用&lt;code&gt;gzip&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.tar.gz&lt;/code&gt;或者&lt;code&gt;.tgz&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;表示显示压缩的过程，会列出所有被压缩的文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;指定压缩文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;tar&lt;/code&gt;支持不同的压缩格式，除了&lt;code&gt;gzip&lt;/code&gt;之外，还有：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;j&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;bzip2&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.bz2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--lzip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;lzip&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.lz&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--xz&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;xz&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.xz&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--lzma&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;采用&lt;code&gt;lzma&lt;/code&gt;的压缩格式，文件后缀通常为&lt;code&gt;.lzma&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更多格式可以参考&lt;a href=&#34;http://www.gnu.org/software/tar/manual/html_node/gzip.html&#34;&gt;这里&lt;/a&gt;。当然，最为常用的两种格式为&lt;code&gt;gzip&lt;/code&gt;跟&lt;code&gt;bzip2&lt;/code&gt;，用法示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar czvf tmp.tgz tmp/
tar cjvf tmp.bz2 tmp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;v&lt;/code&gt;参数可选，如果不需要显示压缩过程的话。需要注意的是，&lt;code&gt;tar&lt;/code&gt;压缩目录的时候会保持目录的结构。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解压文件&lt;/p&gt;

&lt;p&gt;对应于不同的压缩格式，解压参数稍微不一样，对于&lt;code&gt;gzip&lt;/code&gt;跟&lt;code&gt;bzip2&lt;/code&gt;分别示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar xzvf tmp.tgz
tar xjvf tmp.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与压缩不同，&lt;code&gt;c&lt;/code&gt;换成&lt;code&gt;x&lt;/code&gt;表示解压，其它参数含义与压缩一样。默认情况下，解压的文件会放在当前目录，如果需要解压到某个目录下，则可以用&lt;code&gt;-C&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar xzvf -C /tmp/ tmp.tgz
tar xjvf -C /tmp/ tmp.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列出压缩包里面的文件&lt;/p&gt;

&lt;p&gt;有时候我们需要先看看压缩包里面有哪些文件，但又并不想解压文件，可以采用&lt;code&gt;-t&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar czf tmp.tgz tmp/
# tar tvf tmp.tgz
drwxr-xr-x root/root         0 2017-11-17 02:46 tmp/
-rw-r--r-- root/root         0 2017-11-16 00:17 tmp/Test1
-rw-r--r-- root/root       102 2017-11-17 00:30 tmp/test.log
-rw-r--r-- root/root        34 2017-11-17 02:46 tmp/test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;tvf&lt;/code&gt;会列出压缩包中的文件，不论采用何种压缩格式，甚至是没有被压缩的TAR文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从压缩包中提取特定的文件&lt;/p&gt;

&lt;p&gt;在列出压缩包里面的内容后，如果只想提取里面的某些文件，可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar xzvf tmp.tgz tmp/test.log tmp/test2
tmp/test.log
tmp/test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，根据不同的压缩格式请替换成不同的参数。请务必注意，指定的文件必须是完整的路径，而不能只是文件名。&lt;/p&gt;

&lt;p&gt;另外，如果想提取一组匹配某种条件的文件，可以使用&lt;code&gt;--wildcards&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tar xzvf tmp.tgz --wildcards &amp;quot;*.log&amp;quot;
tmp/test.log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;split命令&#34;&gt;split命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;split&lt;/code&gt;命令用来将一个文件分成多个文件，比如将一个特别大的文件分成平均大小为40M的多个文件等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# split -b 40M go1.6.linux-amd64.tar.gz go1.6.linux-amd64.tar.gz.part
# ll go1.6.linux-amd64.tar.gz.part*
-rw-r--r--. 1 root root 41943040 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partaa
-rw-r--r--. 1 root root 41943040 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partab
-rw-r--r--. 1 root root   913400 Nov 20 15:03 go1.6.linux-amd64.tar.gz.partac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;go1.6.linux-amd64.tar.gz&lt;/code&gt;是要被拆分的文件，&lt;code&gt;go1.6.linux-amd64.tar.gz.part&lt;/code&gt;是拆分后文件的前缀，可以看到文件被拆分为三部分了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;split&lt;/code&gt;非常常见的用法是来将某个被压缩的文件拆分成小的部分，正如上例所示。那么，如何将拆分的文件重新合并呢？我们可以用&lt;code&gt;cat&lt;/code&gt;将它们合并：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat go1.6.linux-amd64.tar.gz.part* &amp;gt; go1.6.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;grep命令&#34;&gt;grep命令&lt;/h1&gt;

&lt;p&gt;过滤数据来说，用的最多的估计就是&lt;code&gt;grep&lt;/code&gt;命令了，&lt;code&gt;grep&lt;/code&gt;命令可以从文件或者管道中搜索数据并打印出来，当然，其也可以直接在目录中搜索所有的文件，并把其中符合条件的行打印出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log | grep hello
hello
# grep hello test.log
hello
# grep hello . -r
./test.log:hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是三种方式搜索包括&lt;code&gt;hello&lt;/code&gt;关键字的行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;是Linux中使用最为频繁的命令之一，其本身也有非常强大的功能，这一节咱们将详细讲述其比较常见的用法。&lt;/p&gt;

&lt;h2 id=&#34;基本查找&#34;&gt;基本查找&lt;/h2&gt;

&lt;p&gt;查看&lt;code&gt;grep&lt;/code&gt;的帮助可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# grep --help
Usage: grep [OPTION]... PATTERN [FILE]...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;OPTION&lt;/code&gt;指的是命令参数，&lt;code&gt;PATTERN&lt;/code&gt;指的是匹配的字符串，比如关键字搜索。&lt;code&gt;FILE&lt;/code&gt;指的是文件，当然，没有文件的时候也可以通过管道接收数据并搜索过滤。&lt;code&gt;grep&lt;/code&gt;提供了非常多的命令参数用来控制查找的方式跟效果，下面列举其常用的一些参数：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;默认情况下，&lt;code&gt;grep&lt;/code&gt;命令的搜索是大小写敏感的，如果需要忽略大小写可以用这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;该参数表示不包含的意思&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-A2&lt;/td&gt;
&lt;td&gt;其中&lt;code&gt;A&lt;/code&gt;是&lt;code&gt;after&lt;/code&gt;的意思，表示同时显示搜索出来行后面两行。有时候我们需要知道匹配行后面是什么，可以用这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-B2&lt;/td&gt;
&lt;td&gt;与&lt;code&gt;A&lt;/code&gt;相反，其是&lt;code&gt;before&lt;/code&gt;的意思，表示同时显示匹配行前两行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-C2&lt;/td&gt;
&lt;td&gt;有时候我们想既显示前面两行也显示后面两行，这时候就用这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;搜索目录的时候需要带上这个参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;有些时候，我们需要知道匹配到的行是第几行，可以加上这个参数把行号打印出来&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于&lt;code&gt;PATTERN&lt;/code&gt;，&lt;code&gt;grep&lt;/code&gt;命令也支持不同的用法：
* 关键字匹配&lt;/p&gt;

&lt;p&gt;这个是最常用的基本用法，匹配是否包括该关键字的行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正则匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了基本的关键字匹配，&lt;code&gt;grep&lt;/code&gt;还支持极为强大的正则表达式的匹配。我们将在下一小节专门讲述正则表达式匹配。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;或匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有时候我们需要匹配某个PATTERN1或者PATTERN2的行，这时候可以这么写&lt;code&gt;PATTERN&lt;/code&gt;：&lt;code&gt;PATTERN1\|PATTERN2&lt;/code&gt;。通过&lt;code&gt;\|&lt;/code&gt;将多个&lt;code&gt;PATTERN&lt;/code&gt;连在一起表示或的意思，只要匹配其中任一个的行都会被打印出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# grep &#39;12306\|test&#39; . -r
./test2:http://abcdefg.test.com
./test2:12306.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;正则表达式匹配&#34;&gt;正则表达式匹配&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;命令支持非常强大的正则匹配，支持三种不同的正则表达式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions&#34;&gt;ERE&lt;/a&gt;(POSIX-Extended Regular Expressions)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions&#34;&gt;BRE&lt;/a&gt;(POSIX_Basic_Regular_Expressions)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://perldoc.perl.org/perlre.html&#34;&gt;Perl Regular expression&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，比较常用的是&lt;code&gt;ERE&lt;/code&gt;正则表达式了。在&lt;code&gt;grep&lt;/code&gt;命令中，采用&lt;code&gt;-E&lt;/code&gt;参数即可以使用该表达式，正则表达式非常灵活，用法非常多，这里列举几个示例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;匹配以关键字开头的行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grep -E &amp;quot;^keyword&amp;quot; . -r
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;匹配以关键字结尾的行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grep -E &amp;quot;keyword$&amp;quot; . -r
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;匹配包含如&lt;code&gt;2017/10/11&lt;/code&gt;日期的行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grep -E &amp;quot;[0-9]{4}/[0-9]{2}/[0-9]{2}&amp;quot; . -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意的是，对于数字的表示，其不支持如&lt;code&gt;\d&lt;/code&gt;这样的表达方式，而需要&lt;code&gt;[0-9]&lt;/code&gt;这样表达。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，如果需要熟练掌握&lt;code&gt;grep&lt;/code&gt;的正则表达式匹配，你必须对正则表达式非常熟悉，这个就不在本篇的范畴了。&lt;/p&gt;

&lt;h1 id=&#34;awk命令&#34;&gt;awk命令&lt;/h1&gt;

&lt;p&gt;要说Linux中最为强大的基本命令有哪些，那&lt;code&gt;awk&lt;/code&gt;无疑会榜上有名，其强大的流式处理能力，很多人甚至写书来专门讲这个命令。这里咱们暂时介绍基本的功能，以后有机会将专门开辟一文来展开。&lt;/p&gt;

&lt;p&gt;一个常见的用法就是把文件中的某几列打印出来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | awk &#39;{print $1, $2, $3}&#39;
Nov 17 00:27:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上例，空格将一行分成了不同的列，咱们希望只把时间显示出来，而时间包括了第1，2，3列，因此，通过&lt;code&gt;awk &#39;{print $1, $2, $3}&#39;&lt;/code&gt;就实现了此功能，其中&lt;code&gt;$1&lt;/code&gt;就是引用第一列。&lt;/p&gt;

&lt;h1 id=&#34;cut命令&#34;&gt;cut命令&lt;/h1&gt;

&lt;p&gt;有时候，一行内的数据并不是通过空格分隔开的，而是通过其它分隔符，那如何显示想要的列呢？通过&lt;code&gt;cut&lt;/code&gt;命令，咱们同样可以轻松实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd
root❌0:0:root:/root:/bin/bash
bin❌1:1:bin:/bin:/sbin/nologin
daemon❌2:2:daemon:/sbin:/sbin/nologin
adm❌3:4:adm:/var/adm:/sbin/nologin
lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
# head -n 5 /etc/passwd | cut -d: -f1
root
bin
daemon
adm
lp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/passwd&lt;/code&gt;中的每一行基本上都是通过&lt;code&gt;:&lt;/code&gt;进行分隔，其中第一列表示用户名，如果咱们只想把用户名输出的话，可以通过&lt;code&gt;cut -d: -f1&lt;/code&gt;来实现，其中&lt;code&gt;-d:&lt;/code&gt;表示以&lt;code&gt;:&lt;/code&gt;号为分隔符，&lt;code&gt;-f1&lt;/code&gt;表示显示第一列。可见，对于&lt;code&gt;cut&lt;/code&gt;命令来说，咱们可以指定分隔符，那么前面通过&lt;code&gt;awk&lt;/code&gt;实现的例子也可以通过&lt;code&gt;cut&lt;/code&gt;来做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | cut -d&amp;quot; &amp;quot; -f1-3
Nov 17 00:27:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-d&amp;quot; &amp;quot;&lt;/code&gt;表示以空格为分隔符（注意，这里的空格必须以引号括起来，不然会被shell展开去除多余空格），&lt;code&gt;-f1-3&lt;/code&gt;表示输出第1到3列，这里简用了&lt;code&gt;-&lt;/code&gt;来表示范围，当然也可以写成&lt;code&gt;-f1,2,3&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;cut&lt;/code&gt;命令还可以指定输出哪些位的字符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | cut -c1-16
Nov 17 00:27:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;-c1-16&lt;/code&gt;表示输出第1到16个字符，当然，你同样可以以&lt;code&gt;,&lt;/code&gt;来分别列举要输出哪几个。&lt;/p&gt;

&lt;h1 id=&#34;tr命令&#34;&gt;tr命令&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;tr&lt;/code&gt;其实是&lt;code&gt;translate&lt;/code&gt;的缩写，这个命令用来将某些字符翻译成另外的字符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# tr --help
Usage: tr [OPTION]... SET1 [SET2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令就是把字符集&lt;code&gt;SET1&lt;/code&gt;中的字符对应的转成字符集&lt;code&gt;SET2&lt;/code&gt;中的字符。如将小写转成大写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test.log
Nov 17 00:27:20 traffic-base1 named[1212]: managed-keys-zone: Unable to fetch DNSKEY set .: timed out
# cat test.log | tr a-z A-Z
NOV 17 00:27:20 TRAFFIC-BASE1 NAMED[1212]: MANAGED-KEYS-ZONE: UNABLE TO FETCH DNSKEY SET .: TIMED OUT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用&lt;code&gt;-&lt;/code&gt;来方便的表示一定范围的字符集，当然，你完全可以一个个列出来你要的字符集。通常情况下，&lt;code&gt;SET1&lt;/code&gt;跟&lt;code&gt;SET2&lt;/code&gt;的长度保持一致，因为这个转换实际上是一对一的转换，当然，&lt;code&gt;SET2&lt;/code&gt;的长度是可以大于&lt;code&gt;SET1&lt;/code&gt;的，多余的字符不会被使用。但是，当&lt;code&gt;SET2&lt;/code&gt;长度小于&lt;code&gt;SET1&lt;/code&gt;时，&lt;code&gt;tr&lt;/code&gt;命令会将&lt;code&gt;SET2&lt;/code&gt;中最后一个字符填充不足的位数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &#39;abcdefg&#39; | tr ab wyz
wycdefg
# echo &#39;abcdefg&#39; | tr abcdefg wyz
wyzzzzz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于&lt;code&gt;tr&lt;/code&gt;还有一个常见的用途，就是用来去除字符串中的换行符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# head -n 5 /etc/passwd
root❌0:0:root:/root:/bin/bash
bin❌1:1:bin:/bin:/sbin/nologin
daemon❌2:2:daemon:/sbin:/sbin/nologin
adm❌3:4:adm:/var/adm:/sbin/nologin
lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
# head -n 5 /etc/passwd | tr &#39;\n&#39; &#39; &#39;
root❌0:0:root:/root:/bin/bash bin❌1:1:bin:/bin:/sbin/nologin daemon❌2:2:daemon:/sbin:/sbin/nologin adm❌3:4:adm:/var/adm:/sbin/nologin lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;\n&lt;/code&gt;表示换行符，示例中将换行符全部换成了空格。&lt;/p&gt;

&lt;p&gt;最后，&lt;code&gt;tr&lt;/code&gt;还有一个常见的用法，可以加上&lt;code&gt;-d&lt;/code&gt;参数来删除字符集中的字符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo abcdeWXYZ | tr -d a-z
WXYZ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例中删除了所有小写字母。&lt;/p&gt;

&lt;h1 id=&#34;sed命令&#34;&gt;sed命令&lt;/h1&gt;

&lt;p&gt;流式处理中，&lt;code&gt;sed&lt;/code&gt;也是一个极为常用的命令，它可以用来替换字串，比之前的&lt;code&gt;tr&lt;/code&gt;那是要强大无数倍了。&lt;/p&gt;

&lt;p&gt;查看&lt;code&gt;sed&lt;/code&gt;的帮助：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# sed --help
Usage: sed [OPTION]... {script-only-if-no-other-script} [input-file]...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它既可以直接在文件中替换字符串，也可以加收管道的数据。如基本用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo abcdefgabcd | sed &#39;s/abc/ABC/&#39;
ABCdefgabcd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;&#39;s/abc/ABC/&#39;&lt;/code&gt;指定了替换的规则，默认情况下只替换一次，如果需要全部替换，则需要在规则后面加入&lt;code&gt;g&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo abcdefgabcd | sed &#39;s/abc/ABC/g&#39;
ABCdefgABCd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;规则中默认使用了&lt;code&gt;/&lt;/code&gt;为分隔。当然，你也可以使用其他分隔符，这在要替换的字串中带有&lt;code&gt;/&lt;/code&gt;的时候特别有用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &amp;quot;http://abc.test.com&amp;quot; | sed &#39;s/http:\/\//https:\/\//&#39;
https://abc.test.com
# echo &amp;quot;http://abc.test.com&amp;quot; | sed &#39;s|http://|https://|&#39;
https://abc.test.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不指定新的分隔符&lt;code&gt;|&lt;/code&gt;，那么就得使用转义符&lt;code&gt;\&lt;/code&gt;将&lt;code&gt;//&lt;/code&gt;进行转义了，这样可读性就差了很多，采用&lt;code&gt;|&lt;/code&gt;就自然多了。&lt;code&gt;sed&lt;/code&gt;支持的分隔符还包括了&lt;code&gt;:&lt;/code&gt;，&lt;code&gt;_&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;sed&lt;/code&gt;不仅可以用来替换字串，还可以用来删除匹配的行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# cat test2
http://abcdefg.test.com
12306.com
# cat test2 | sed &#39;/12306/d&#39;
http://abcdefg.test.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;高级用法&#34;&gt;高级用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;后向引用（Back Referencing）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sed&lt;/code&gt;规则匹配到的字符串还可以在规则定义中被引用，如下例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &amp;quot;hello world&amp;quot; | sed &#39;s/hello/&amp;amp;&amp;amp;/&#39;
hellohello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;&amp;amp;&lt;/code&gt;可以用来引用被匹配到的字串，在本例中，匹配到的字串是&lt;code&gt;hello&lt;/code&gt;，这样通过&lt;code&gt;&amp;amp;&lt;/code&gt;就可以引用被匹配到的字串了。此外，我们还可以通过&lt;code&gt;()&lt;/code&gt;来指定匹配的字串，并用&lt;code&gt;\1&lt;/code&gt;（数字表示第一个&lt;code&gt;()&lt;/code&gt;）来引用（实际上是正则表达式中的Grouping）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo Sunday | sed &#39;s/\(Sun\)/\1ny/&#39;
Sunnyday
# echo Sunday | sed &#39;s/\(Sun\)/\1ny \1/&#39;
Sunny Sunday
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;正则匹配&lt;/p&gt;

&lt;p&gt;由上述可以看出，&lt;code&gt;sed&lt;/code&gt;的规则使用了正则表达式规则，但是其书写跟一般的正则书写不一样，你必须将有关的字符转义，否则&lt;code&gt;sed&lt;/code&gt;仍然会将其当做普通字符进行匹配：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;# echo &amp;quot;this is aaaa cat&amp;quot; | sed &#39;s/a{4}/a/&#39;
this is aaaa cat
# echo &amp;quot;this is aaaa cat&amp;quot; | sed &#39;s/a\{4\}/a/&#39;
this is a cat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，在没有转义&lt;code&gt;{&lt;/code&gt;及&lt;code&gt;}&lt;/code&gt;之前，&lt;code&gt;sed&lt;/code&gt;并没有匹配到目标字串&lt;code&gt;aaaa&lt;/code&gt;，而将其转义之后，则以正则表达式&lt;code&gt;a{4}&lt;/code&gt;匹配到了&lt;code&gt;aaaa&lt;/code&gt;并进行了替换。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递归替换&lt;/p&gt;

&lt;p&gt;有时候我们需要在项目目录下替换某个字串，比如把手误写错的&lt;code&gt;#include&amp;lt;stdllib.h&amp;gt;&lt;/code&gt;全部替换成&lt;code&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;，希望被替换的文件包括&lt;code&gt;*.cpp&lt;/code&gt;，&lt;code&gt;*.h&lt;/code&gt;的文件。其中的一种做法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ head -n 1 test.cpp
#include &amp;lt;stdllib.h&amp;gt;
$ sed -i &#39;s/#include &amp;lt;stdllib.h&amp;gt;/#include &amp;lt;stdlib.h&amp;gt;/&#39; `find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot;`
$ head -n 1 test.cpp
#include &amp;lt;stdlib.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里用到了shell嵌入的用法（可以参看&lt;a href=&#34;https://keysaim.github.io/2017/10/10/linux-study-shell-basic/#shell嵌入与shell选项&#34;&gt;这一篇博文&lt;/a&gt;)，通过&lt;code&gt;find&lt;/code&gt;命令找出所有的源文件，然后用&lt;code&gt;sed -i&lt;/code&gt;进行替换，其中&lt;code&gt;-i&lt;/code&gt;表示从文件里面替换。这一用法会将&lt;code&gt;find&lt;/code&gt;找到的所有文件作为参数都追加到&lt;code&gt;sed&lt;/code&gt;命令后，在项目非常大的情况下可能会导致命令执行失败（因为数量庞大的文件导致追加的参数太大了），通常我们推荐采用&lt;code&gt;find&lt;/code&gt;的这种用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;find . -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;*.h&amp;quot; -exec sed -i &#39;s/#include &amp;lt;stdllib.h&amp;gt;/#include &amp;lt;stdlib.h&amp;gt;/&#39; {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体可以参照本文中关于&lt;code&gt;find&lt;/code&gt;命令的介绍。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（四）IO重定向与管道</title>
      <link>https://keysaim.github.io/post/linux/2017-11-16-linux-study-io-pipe/</link>
      <pubDate>Thu, 16 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-11-16-linux-study-io-pipe/</guid>
      
        <description>

&lt;h1 id=&#34;io重定向-io-redirection&#34;&gt;IO重定向(IO redirection)&lt;/h1&gt;

&lt;p&gt;Linux的有一个强大之处就是可以通过管道(Pipe)跟IO重定向将一系列命令的输出跟输入连接起来。IO重定向是Linux中非常重要的概念，是理解Linux命令，脚本以及Linux IO的基础。&lt;/p&gt;

&lt;h2 id=&#34;标准输入输出&#34;&gt;标准输入输出&lt;/h2&gt;

&lt;p&gt;对于&lt;code&gt;shell&lt;/code&gt;来说，有三个基础的流，标准输入流(stdin或者stream 0)，标准输出流(stdout或者stream 1)，标准错误流(stderr或者stream2)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keysaim.github.io/img/blog-linux-shell-stdinout.png&#34; alt=&#34;标准输入输出&#34; /&gt;&lt;/p&gt;

&lt;p&gt;举个例子，当我们用键盘在&lt;code&gt;shell&lt;/code&gt;中执行命令的时候，可以如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keysaim.github.io/img/blog-linux-shell-keyboard-stdinout.png&#34; alt=&#34;键盘输入输出&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通常，stdout跟stderr都输出到了屏幕上，但对于Linux来说，其实是两种不同的输出。&lt;/p&gt;

&lt;h2 id=&#34;输出重定向&#34;&gt;输出重定向&lt;/h2&gt;

&lt;p&gt;可以用&lt;code&gt;&amp;gt;&lt;/code&gt;大于号将stdout重定向到另一个IO，比如文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo &amp;quot;hello&amp;quot; &amp;gt; test.log
# cat test.log
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令将stdout重定向到文件&lt;code&gt;test.log&lt;/code&gt;中，此时，如果该文件不存在则创建新文件，如果存在则覆盖已有文件。事实上，&lt;code&gt;&amp;gt;&lt;/code&gt;重定向是&lt;code&gt;1&amp;gt;&lt;/code&gt;的简写，&lt;code&gt;1&amp;gt;&lt;/code&gt;可以更清楚的看到实际上是把stdout(stream 1)重定向。&lt;/p&gt;

&lt;p&gt;必须注意的是，默认情况下，该重定向会覆盖已有文件，这个在有时候可能不经意间丢失重要数据。&lt;code&gt;shell&lt;/code&gt;提供了选项使得我们可以禁止这种覆盖，&lt;code&gt;set -o noclobber&lt;/code&gt;可以打开该选项。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat test.log
hello
# set -o noclobber
# echo &amp;quot;world&amp;quot; &amp;gt; test.log
-bash: test.log: cannot overwrite existing file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，在打开该选项之后，其实还是可以强制执行覆盖，可以采用&lt;code&gt;&amp;gt;|&lt;/code&gt;来强制重定向到已存在的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo &amp;quot;world&amp;quot; &amp;gt; test.log
-bash: test.log: cannot overwrite existing file
# echo &amp;quot;world&amp;quot; &amp;gt;| test.log
# cat test.log
world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;追加输出&#34;&gt;追加输出&lt;/h2&gt;

&lt;p&gt;可以采用&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;将输出重定向到文件并追加在文件结尾，这样就可以避免覆盖文件了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat test.log
world
# echo hello &amp;gt;&amp;gt; test.log
# cat test.log
world
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标准错误重定向&#34;&gt;标准错误重定向&lt;/h2&gt;

&lt;p&gt;如&lt;code&gt;1&amp;gt;&lt;/code&gt;一样，我们可以通过&lt;code&gt;2&amp;gt;&lt;/code&gt;将stderr重定向到文件，具体行为跟stdout类似。&lt;/p&gt;

&lt;h2 id=&#34;同时重定向stdout跟stderr&#34;&gt;同时重定向stdout跟stderr&lt;/h2&gt;

&lt;p&gt;我们可以在同一行命令中同时将stdout跟stderr重定向，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt*
ls: cannot access tttt*: No such file or directory
test.log  test2
# ls test* tttt* &amp;gt; stdout.log 2&amp;gt; stderr.log
# cat stdout.log
test.log
test2
# cat stderr.log
ls: cannot access tttt*: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，stdout跟stderr被分别重定向到&lt;code&gt;stdout.log&lt;/code&gt;跟&lt;code&gt;stderr.log&lt;/code&gt;文件中了。&lt;/p&gt;

&lt;p&gt;此外，还有一个常见的用法是将stderr重定向到stdout，这样就可以将所有输出都定向在一起了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt* &amp;gt; stdout.log
ls: cannot access tttt*: No such file or directory
# cat stdout.log
test.log
test2
# ls test* tttt* &amp;gt; stdout.log 2&amp;gt;&amp;amp;1
# cat stdout.log
ls: cannot access tttt*: No such file or directory
test.log
test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，通过&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;将stderr重定向给stdout，而stdout又重定向给文件&lt;code&gt;stdout.log&lt;/code&gt;，这样所有的输出都重定向到文件&lt;code&gt;stdout.log&lt;/code&gt;中了。另外，还可以通过&lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt;直接将stderr跟stdout合并：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* &amp;amp;&amp;gt; stdout.log
# cat stdout.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重定向顺序&#34;&gt;重定向顺序&lt;/h2&gt;

&lt;p&gt;将stderr重定向给stdout的时候，请务必注意其顺序，如上面的重定向如果写成这样，结果就完全不同了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt* 2&amp;gt;&amp;amp;1 &amp;gt; stdout.log
ls: cannot access tttt*: No such file or directory
# cat stdout.log
test.log
test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，stderr其实并没有被重定向到文件&lt;code&gt;stdout.log&lt;/code&gt;中，可见顺序是非常重要的。那么，如果理解这种不同呢？咱们可以这么样来理解：
* 将&lt;code&gt;&amp;gt;&lt;/code&gt;看作是&lt;code&gt;shell&lt;/code&gt;中的赋值操作&lt;code&gt;=&lt;/code&gt;
* 将stdout跟stderr看作是变量，但对其引用采用&lt;code&gt;&amp;amp;&lt;/code&gt;，这样&lt;code&gt;&amp;amp;1&lt;/code&gt;表示对stdout变量的引用
* 假定stdout跟stderr变量的初始值是屏幕，将屏幕记为&lt;code&gt;/dev/tty&lt;/code&gt;
* &lt;code&gt;shell&lt;/code&gt;从左到有扫描解释命令，并对stdout跟stderr分别赋值
* 查看stdout跟stderr的最终值即可知道分别被重定向到哪里了&lt;/p&gt;

&lt;p&gt;还是以上面的例子来解释，&lt;code&gt;ls test* tttt* 2&amp;gt;&amp;amp;1 &amp;gt; stdout.log&lt;/code&gt;
* 命令开始前，stdout=/dev/tty, stderr=/dev/tty
* &lt;code&gt;shell&lt;/code&gt;从左到右扫描并重新赋值，首先&lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;就相当于&lt;code&gt;stderr=$stdin&lt;/code&gt;，此时&lt;code&gt;stderr&lt;/code&gt;的值其实还是&lt;code&gt;/dev/tty&lt;/code&gt;
* &lt;code&gt;&amp;gt; stdout.log&lt;/code&gt;就相当于&lt;code&gt;stdout=stdout.log&lt;/code&gt;，此时stdout值为&lt;code&gt;stdout.log&lt;/code&gt;
* 最后，stdout值为&lt;code&gt;stdout.log&lt;/code&gt;，而stderr值仍然为&lt;code&gt;/dev/tty&lt;/code&gt;，所以只有stdout输出到文件&lt;code&gt;stdout.log&lt;/code&gt;中了&lt;/p&gt;

&lt;p&gt;基于这个原则，在讲述完管道之后咱们将展示如何把stdout跟stderr交换一下。&lt;/p&gt;

&lt;h2 id=&#34;输入重定向&#34;&gt;输入重定向&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;既然输出有重定向，那么输入是否也可以呢？答案是肯定的，可以采用&lt;code&gt;&amp;lt;&lt;/code&gt;将输入重定向，&lt;code&gt;&amp;lt;&lt;/code&gt;其实是&lt;code&gt;0&amp;lt;&lt;/code&gt;的简写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat stdout.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
# cat &amp;lt;stdout.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，还可以&lt;code&gt;&amp;lt;&amp;lt;EOF&lt;/code&gt;通过手动输入直到输入&lt;code&gt;EOF&lt;/code&gt;（或者Ctrl-D）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;符号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该符号可以直接将一个字符串重定向给输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# base64 &amp;lt;&amp;lt;&amp;lt; hello
aGVsbG8K
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;base64&lt;/code&gt;命令参数只接受文件，通过这种方式就可以把字符串直接传给它。&lt;/p&gt;

&lt;h2 id=&#34;输入输出同时重定向&#34;&gt;输入输出同时重定向&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;是可以支持同时重定向输入跟输出的，以下方式都会被准确解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;lt;test.log &amp;gt; stdout.log 2&amp;gt; stderr.log
# &amp;lt;test.log &amp;gt; stdout.log 2&amp;gt; stderr.log cat
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;快速清除文件内容&#34;&gt;快速清除文件内容&lt;/h2&gt;

&lt;p&gt;可以通过重定向快速的清空文件内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat test.log
hello world
# &amp;gt; test.log
# cat test.log
#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，咱们并不需要写&lt;code&gt;echo &amp;quot;&amp;quot; &amp;gt; test.log&lt;/code&gt;这样的命令来清空一个文件。当&lt;code&gt;noclobber&lt;/code&gt;选项被打开时，可以通过&lt;code&gt;&amp;gt;|&lt;/code&gt;来强制清空。&lt;/p&gt;

&lt;h1 id=&#34;管道-pipe&#34;&gt;管道(Pipe)&lt;/h1&gt;

&lt;p&gt;在Linux中，我们可以使用管道(Pipe)将前一个命令的stdout作为输入给后面一个命令，管道由&lt;code&gt;|&lt;/code&gt;表示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls test* tttt*
ls: cannot access tttt*: No such file or directory
test.log  test2
# ls -l test* tttt* | grep log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请务必注意的是，管道只会将stdout传递给下一个命令，stderr并不会传递，为了证明这一点，咱们将后一个命令的stderr重定向到文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* | grep log 2&amp;gt; stderr.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
# cat stderr.log
# 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时可以看出，第二个命令的stderr为空，而第一个命令的stderr仍输出到屏幕了。当然，咱们也可以将第一个命令的stderr重定向到stdout上，这样&lt;code&gt;grep&lt;/code&gt;命令也可以收到了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* 2&amp;gt;&amp;amp;1 | grep &amp;quot;No &amp;quot;
ls: cannot access tttt*: No such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再回到上一节的问题，咱们如何将stdout跟stderr互相交换一下呢？可以这么做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls -l test* tttt* 3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3 | grep &amp;quot;No &amp;quot; 2&amp;gt; stderr.log
ls: cannot access tttt*: No such file or directory
-rw-r--r--. 1 root root 12 Nov 16 01:02 test.log
-rw-r--r--. 1 root root  0 Nov 16 00:17 test2
# cat stderr.log
# 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的Linux发行版本对grep输出的颜色设置正确，会发现只有第一行是grep出来的，由此可见&lt;code&gt;3&amp;gt;&amp;amp;1 1&amp;gt;&amp;amp;2 2&amp;gt;&amp;amp;3&lt;/code&gt;居然将stdout跟stderr互换了一下，至于怎么解释，可以参照前面的赋值方式自行拆解一下。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>GPS管理系统服务器迁移指南</title>
      <link>https://keysaim.github.io/post/others/2017-10-11-rushgps-migrate/</link>
      <pubDate>Wed, 11 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/others/2017-10-11-rushgps-migrate/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本指南主要讲述如何将GPS管理系统服务器迁移到另一台新的服务器，假定要迁移的服务器为server1，新服务器为server2，假定的服务器参数如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;服务器&lt;/th&gt;
&lt;th&gt;操作系统&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;外网地址&lt;/th&gt;
&lt;th&gt;外网开放端口&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;server1&lt;/td&gt;
&lt;td&gt;Centos 7&lt;/td&gt;
&lt;td&gt;10.10.10.100&lt;/td&gt;
&lt;td&gt;55.55.55.100&lt;/td&gt;
&lt;td&gt;9999, 9998&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;server2&lt;/td&gt;
&lt;td&gt;Centos 7&lt;/td&gt;
&lt;td&gt;10.10.10.101&lt;/td&gt;
&lt;td&gt;55.55.55.101&lt;/td&gt;
&lt;td&gt;9999, 9998&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;一下所有操作都以root权限进行，请务必注意&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&#34;备份server1上的数据&#34;&gt;备份server1上的数据&lt;/h1&gt;

&lt;p&gt;请以ssh登陆到服务器，并切换到root用户。&lt;/p&gt;

&lt;h2 id=&#34;备份repo数据&#34;&gt;备份repo数据&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
cp -f /etc/yum.repos.d/mysql-community.repo /
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;备份数据库数据&#34;&gt;备份数据库数据&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
mysqldump -u root -p rushgps &amp;gt; rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入数据库密码完成备份，生成的备份文件为&lt;code&gt;rushgps.sql&lt;/code&gt;，其中数据库密码请联系维护人员索取，这里假定是&lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;备份管理系统部署文件&#34;&gt;备份管理系统部署文件&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
tar czf root.tgz root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的备份文件为&lt;code&gt;root.tgz&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;备份管理系统资源文件&#34;&gt;备份管理系统资源文件&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
tar czf opt.tgz opt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成的备份文件为&lt;code&gt;opt.tgz&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;备份supervisord配置&#34;&gt;备份supervisord配置&lt;/h2&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cp -f /etc/supervisord.conf /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结，所有备份文件如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;备份文件&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/mysql-community.repo&lt;/td&gt;
&lt;td&gt;repo文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/rushgps.sql&lt;/td&gt;
&lt;td&gt;数据库备份文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/root.tgz&lt;/td&gt;
&lt;td&gt;部署文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/opt.tgz&lt;/td&gt;
&lt;td&gt;资源文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/supervisord.conf&lt;/td&gt;
&lt;td&gt;supervisord文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;安装server2操作系统&#34;&gt;安装server2操作系统&lt;/h1&gt;

&lt;p&gt;其中，server2操作系统安装过程这里不赘述，请确保是Centos 7系统，并配置好网络。&lt;/p&gt;

&lt;h1 id=&#34;迁移备份文件&#34;&gt;迁移备份文件&lt;/h1&gt;

&lt;p&gt;请将第一章中所有的备份文件上传到server2的目录&lt;code&gt;/&lt;/code&gt;下。&lt;/p&gt;

&lt;p&gt;请以ssh登陆到服务器，并切换到root用户。上传完成之后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
tar xzf root.tgz
tar xzf opt.tgz
cp -f /*.repo /etc/yum.repos.d/
cp -f /supervisord.conf /etc/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;部署server2&#34;&gt;部署server2&lt;/h1&gt;

&lt;p&gt;部署过程中需要连接外网，请务必先配置好外网访问。&lt;/p&gt;

&lt;h2 id=&#34;安装mysql&#34;&gt;安装mysql&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装mysql软件&lt;/p&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yum -y install mysql-community-client mysql-community-devel mysql-community-server
systemctl enable mysqld
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化mysql&lt;/p&gt;

&lt;p&gt;安装完成之后需要初始化mysql的root用户密码，请执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl start mysqld
/usr/bin/mysqladmin -u root password &#39;default&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里假定密码是&lt;code&gt;default&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置数据库&#34;&gt;配置数据库&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建数据库&lt;/p&gt;

&lt;p&gt;GPS管理系统需要配置数据库，请执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入配置的密码后回车进入mysql的命令终端，然后再执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-terminal&#34;&gt;mysql&amp;gt; create database rushgps DEFAULT CHARACTER SET utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回车后完成初始化，按Ctrl+C退出。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;恢复数据库&lt;/p&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p rushgps &amp;lt; /rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入配置的密码后回车，完成数据库恢复。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装gps系统依赖包&#34;&gt;安装GPS系统依赖包&lt;/h2&gt;

&lt;p&gt;同样，请务必确保外网访问。&lt;/p&gt;

&lt;p&gt;请执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yum -y install python-devel zlib* gcc make supervisor
cd /root/ws/gpssys
pip install -r requirements.txt
systemctl enable supervisord
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置gps系统&#34;&gt;配置GPS系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建日志目录&lt;/p&gt;

&lt;p&gt;命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir -p /var/log/gpssys
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑GPS配置文件&lt;code&gt;/root/ws/gpssys/carerp/settings.py&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;找到&lt;code&gt;ALLOWED_HOSTS =&lt;/code&gt;这行，将server2的本地IP以及外网IP加入进去。&lt;/li&gt;
&lt;li&gt;找到&lt;code&gt;DATABASES =&lt;/code&gt;这行，往下找到&lt;code&gt;PASSWORD&lt;/code&gt;配置项，将它改成配置的mysql密码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动GPS系统&lt;/p&gt;

&lt;p&gt;执行一下命令启动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl start supervisord
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，系统迁移完成，可以用浏览器打开系统&lt;code&gt;http://&amp;lt;server2 IP&amp;gt;:9999&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;系统维护篇&#34;&gt;系统维护篇&lt;/h1&gt;

&lt;h2 id=&#34;备份数据库&#34;&gt;备份数据库&lt;/h2&gt;

&lt;p&gt;请务必定期备份数据库，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;备份命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /
mysqldump -u root -p rushgps &amp;gt; rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请将生成的备份文件&lt;code&gt;rushgps.sql&lt;/code&gt;拷贝到贵公司的保存数据的服务器上。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;恢复命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mysql -u root -p rushgps &amp;lt; rushgps.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;重启gps系统&#34;&gt;重启GPS系统&lt;/h2&gt;

&lt;p&gt;如果碰到任何问题，请重启GPS系统：&lt;/p&gt;

&lt;p&gt;命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl restart supervisord
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（三）shell基础</title>
      <link>https://keysaim.github.io/post/linux/2017-10-10-linux-study-shell-basic/</link>
      <pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-10-linux-study-shell-basic/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;首先，咱们来了解一下，什么是&lt;code&gt;Shell&lt;/code&gt;。操作系统内核给我们提供了各种接口，同时也提供了各种用户层的库，理论上我们基于这些可以编写程序实现各种我们想要的功能，不过问题是，咱们不可能做什么事情都要重新编写程序，这样使用起来也太困难了。因此，操作系统（包括Linux）通常都会引入一个&lt;code&gt;Shell&lt;/code&gt;这样的特殊程序，这个程序会接受输入的命令然后执行，并可能将执行结果呈现出来。总结来说，&lt;code&gt;Shell&lt;/code&gt;是一个从输入设备或者文件读取命令，并且解释、执行的用户态程序。&lt;/p&gt;

&lt;p&gt;在Linux系统中，通常使用的&lt;code&gt;Shell&lt;/code&gt;程序包括有：
* Sh (Bourne Shell)
* Bash (Bourne Again Shell)
* Csh (C Shell)
* Ksh (Korn Shell)&lt;/p&gt;

&lt;p&gt;一般来说，&lt;code&gt;Bash&lt;/code&gt;应该是使用最多的&lt;code&gt;Shell&lt;/code&gt;程序了，本文也主要基于&lt;code&gt;Bash&lt;/code&gt;来展开。&lt;/p&gt;

&lt;h1 id=&#34;shell展开-shell-expansion&#34;&gt;Shell展开（Shell Expansion）&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Shell&lt;/code&gt;程序是一个命令解释器，因此在终端输入命令之后，&lt;code&gt;Shell&lt;/code&gt;将扫描命令并做适当的修改，这个过程称为Shell展开。Shell展开是Shell解释执行之前极为重要的一步，了解它将有利于你对Shell命令或者脚本的理解，本章节将逐步带大家来了解这个过程。&lt;/p&gt;

&lt;h2 id=&#34;命令参数解析&#34;&gt;命令参数解析&lt;/h2&gt;

&lt;p&gt;这里的空格包括了制表符（Tab）。当Shell程序扫描输入的命令时，会以*连续*的空格为界，将命令切分成一组参数，因此你输入多个空格为界跟输入一个空格的效果是一样的。通常来讲，第一个参数就是要执行的命令，而后面的参数则是改命令的参数。一下几个命令其实是等效的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo Hello World
Hello World
# echo   Hello World
Hello World
#    echo Hello World
Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引号&#34;&gt;引号&lt;/h2&gt;

&lt;p&gt;当然，有时候你需要在一个参数中包括空格，这样的话你就需要将这个参数以引号引起来，引号包括了单引号&lt;code&gt;&#39;&lt;/code&gt;跟双引号&lt;code&gt;&amp;quot;&lt;/code&gt;，两者都可以。&lt;code&gt;shell&lt;/code&gt;会将引号中的字符串视为一个参数，不论里面有没有空格。当然，特别指出的是，不要用反引号&lt;code&gt;`&lt;/code&gt;，反引号将在后面详细讲述。&lt;/p&gt;

&lt;p&gt;如命令&lt;code&gt;echo &#39;Hello World!&#39;&lt;/code&gt;在&lt;code&gt;shell&lt;/code&gt;解析之后会有两个参数，分别为&lt;code&gt;echo&lt;/code&gt;跟&lt;code&gt;Hello World!&lt;/code&gt;。而如果不用引号&lt;code&gt;echo Hello World!&lt;/code&gt;，则将解析为三个参数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特别提一下，对于&lt;code&gt;echo&lt;/code&gt;命令，如果需要输出需要转义的字符，如回车等，则需要执行&lt;code&gt;echo -e &amp;quot;Hello World!\n&amp;quot;&lt;/code&gt;，如果不加&lt;code&gt;-e&lt;/code&gt;，则&lt;code&gt;\n&lt;/code&gt;会被直接显示出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;    # echo &amp;quot;hello\n&amp;quot;
&amp;gt;    hello\n
&amp;gt;    # echo -e &amp;quot;hello\n&amp;quot;
&amp;gt;    hello
&amp;gt;
&amp;gt;    ```

## 命令

对于`shell`来说，命令有内部命令（Builtin Commands）跟外部命令（External Commands）之分，所谓内部命令指的是包含在`shell`解析器中的命令。内部命令一般有[4种类型](http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands)：

* `sh`内部命令

    这些内部命令来源于`Bourne Shell`，通常包括了以下命令：
    `: . break cd continue eval exec exit export getopts hash pwd readonly return shift test/[ times trap umask unset`。

* `bash`内部命令

    这些内部命令来源于`Bourne Again Shell`，通常包括了以下命令：
    `alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias`。

* 修改`shell`行为的内部命令

    这些内部命令用来修改`shell`的默认行为。包括了`set shopt`命令。

* 特殊内部命令

    由于历史原因，POSIX标准将一些内部命令划分为特殊内部命令，特殊的之处在于这些命令的查找时间以及命令运行后的状态等方面，只有当Bash以[POSIX模式](http://www.gnu.org/software/bash/manual/bashref.html#Bash-POSIX-Mode)运行时，这些命令才是特殊命令，否则它们跟其它内部命令没啥区别。特殊内部命令包括了`break : . continue eval exec exit export readonly return set shift trap unset`。

**内部命令可能会被提前至于内存中，因此运行起来会比外部命令要快。**对于外部命令，可以认为除了内部命令之后就可以认为是外部命令了，通常来讲，`/bin`跟`/sbin`下的都是外部命令，当然，应用有关的通常也是外部命令。

我们可以通过`type`命令来查看一个命令是否是内部命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-cd&#34;&gt;type cd&lt;/h1&gt;

&lt;p&gt;cd is a shell builtin&lt;/p&gt;

&lt;h1 id=&#34;type-awk&#34;&gt;type awk&lt;/h1&gt;

&lt;p&gt;awk is /usr/bin/awk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
另外，对于很多内部命令，它们可能对应的会有外部命令版本，可以通过`type`命令来查看：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-a-echo&#34;&gt;type -a echo&lt;/h1&gt;

&lt;p&gt;echo is a shell builtin
echo is /usr/bin/echo&lt;/p&gt;

&lt;h1 id=&#34;type-a-cd&#34;&gt;type -a cd&lt;/h1&gt;

&lt;p&gt;cd is a shell builtin
cd is /usr/bin/cd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
反过来，我们一般可以通过命令`which`来查询一个命令是否是外部命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;which-awk&#34;&gt;which awk&lt;/h1&gt;

&lt;p&gt;/usr/bin/awk&lt;/p&gt;

&lt;h1 id=&#34;which&#34;&gt;which .&lt;/h1&gt;

&lt;p&gt;/usr/bin/which: no . in (/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
总结一下，通过`which`查询出来的是其外部命令版本，通过`type`默认查询出来的是内部命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;which-echo&#34;&gt;which echo&lt;/h1&gt;

&lt;p&gt;/usr/bin/echo&lt;/p&gt;

&lt;h1 id=&#34;type-echo&#34;&gt;type echo&lt;/h1&gt;

&lt;p&gt;echo is a shell builtin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
对于内部命令的详细说明，可以查看[GNU的文档](http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands)。

## 别名

可以用`alias`命令给一个命令取一个别名：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;alias-print-echo&#34;&gt;alias print=echo&lt;/h1&gt;

&lt;h1 id=&#34;print-hello&#34;&gt;print &amp;ldquo;hello&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;hello&lt;/p&gt;

&lt;h1 id=&#34;type-print&#34;&gt;type print&lt;/h1&gt;

&lt;p&gt;print is aliased to `echo&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
别名一个常用的用法是用来缩写已知的命令：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-ls&#34;&gt;type ls&lt;/h1&gt;

&lt;p&gt;ls is aliased to `ls &amp;ndash;color=auto&amp;rsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
可见`ls`命令实际上是命令`ls --color=auto`的别名，这样就相当于改变了`ls`命令的默认行为了。在这种情况下，如果仍然想用原先的命令，可以在别名前加反斜杠`` \ ``：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;type-ls-1&#34;&gt;type ls&lt;/h1&gt;

&lt;p&gt;ls is aliased to `ls &amp;ndash;color=auto&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;ls&#34;&gt;\ls&lt;/h1&gt;

&lt;p&gt;Test1  test2  test.cpp  test.log  time.log&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

前面咱们通过`type`命令来查看命令的别名，实际上更加推荐采用`alias`或者`which`来查看：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;alias-ls&#34;&gt;alias ls&lt;/h1&gt;

&lt;p&gt;alias ls=&amp;lsquo;ls &amp;ndash;color=auto&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;which-ls&#34;&gt;which ls&lt;/h1&gt;

&lt;p&gt;alias ls=&amp;lsquo;ls &amp;ndash;color=auto&amp;rsquo;
    /usr/bin/ls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
如果要取消别名，则可以采用`unalias`命令:

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;which-ls-1&#34;&gt;which ls&lt;/h1&gt;

&lt;p&gt;alias ls=&amp;lsquo;ls &amp;ndash;color=auto&amp;rsquo;
    /usr/bin/ls&lt;/p&gt;

&lt;h1 id=&#34;unalias-ls&#34;&gt;unalias ls&lt;/h1&gt;

&lt;h1 id=&#34;which-ls-2&#34;&gt;which ls&lt;/h1&gt;

&lt;p&gt;/usr/bin/ls&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

## 显示shell展开的结果

由于`shell`展开的存在，你输入的命令被展开之后可能会发生变化，如果需要知道`shell`展开之后的命令，可以使用内部命令`set`来修改`shell`的默认参数来显示：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;set-x&#34;&gt;set -x&lt;/h1&gt;

&lt;p&gt;++ printf &amp;lsquo;\033]0;%s@%s:%s\007&amp;rsquo; root traffic-base1 &amp;lsquo;~&amp;rsquo;&lt;/p&gt;

&lt;h1 id=&#34;echo-hello-world&#34;&gt;echo hello         world&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;echo hello world
hello world
++ printf &amp;lsquo;\033]0;%s@%s:%s\007&amp;rsquo; root traffic-base1 &amp;lsquo;~&amp;rsquo;
```&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，以&lt;code&gt;+&lt;/code&gt;开头的就是展开之后的命令，可见展开之后，&lt;code&gt;shell&lt;/code&gt;将多余的空格去掉了。如果不要再显示了，可以输入命令&lt;code&gt;set +x&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&#34;shell控制操作符-control-operators&#34;&gt;shell控制操作符 (Control Operators）&lt;/h1&gt;

&lt;h2 id=&#34;操作符&#34;&gt;&lt;code&gt;$?&lt;/code&gt;操作符&lt;/h2&gt;

&lt;p&gt;每个命令执行完后都会有个退出码（Exit Code），其值为0时表示命令成功，否则命令失败。这个退出码可以通过&lt;code&gt;$?&lt;/code&gt;来访问，执行完命令后立马访问&lt;code&gt;$?&lt;/code&gt;可以获取该命令的退出码，并以此来判断命令是否成功。每个命令的执行都会产生新的退出码，所以请务必在命令执行完，立刻访问&lt;code&gt;$?&lt;/code&gt;来获取退出码。&lt;/p&gt;

&lt;p&gt;初看起来，&lt;code&gt;$?&lt;/code&gt;似乎是一个&lt;code&gt;shell&lt;/code&gt;变量，但实际上并非如此，因为你无法对&lt;code&gt;$?&lt;/code&gt;赋值。&lt;code&gt;$?&lt;/code&gt;准确来说是&lt;code&gt;shell&lt;/code&gt;的一个内部参数。&lt;/p&gt;

&lt;h2 id=&#34;分号&#34;&gt;分号&lt;code&gt;;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;命令输入时，你可以将多个命令输入在一行，只要在不同命令之间以分号&lt;code&gt;;&lt;/code&gt;隔开，当然分号不能是在引号中。
&amp;gt; 必须注意的是，如果将多个命令以&lt;code&gt;;&lt;/code&gt;连接在一起，执行的结果通过&lt;code&gt;$?&lt;/code&gt;查询出来将只是最后一个命令的结果&lt;/p&gt;

&lt;h2 id=&#34;符号&#34;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;符号&lt;/h2&gt;

&lt;p&gt;通常情况下，&lt;code&gt;shell&lt;/code&gt;会在前台执行命令，并等待命令结束才返回。如果需要将命令放到后台去执行，可以使用&lt;code&gt;&amp;amp;&lt;/code&gt;符号放在命令最后面，这样的话命令会被放在后台执行，&lt;code&gt;shell&lt;/code&gt;会立刻返回而不用等待命令结束。
&amp;gt; 注意的是，即便放在后台执行，但是如果不处理好命令的输入，则命令的输出可能会继续在当前的终端输出，后面会讲述如何处理命令的输出。&lt;/p&gt;

&lt;h2 id=&#34;操作符-1&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;操作符&lt;/h2&gt;

&lt;p&gt;此操作符表示逻辑与，你可以将两个命令用此操作符连接起来，如&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;，只有当&lt;code&gt;cmd1&lt;/code&gt;执行成功之后，&lt;code&gt;cmd2&lt;/code&gt;才会被执行。这里的成功指的是&lt;code&gt;cmd1&lt;/code&gt;的退出码是0。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# hello &amp;amp;&amp;amp; echo world
-bash: hello: command not found
# echo hello &amp;amp;&amp;amp; echo world
hello
world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;也可以将多个命令连接起来，其执行类似，只有当前面的命令成功，后面的才会执行。因此，将多个命令写在一行用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;可以实现，只不过&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;必须按照逻辑与的关系执行，而&lt;code&gt;;&lt;/code&gt;号的话会执行所有的命令。&lt;/p&gt;

&lt;h2 id=&#34;操作符-2&#34;&gt;&lt;code&gt;||&lt;/code&gt;操作符&lt;/h2&gt;

&lt;p&gt;很显然，与&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;相对，&lt;code&gt;||&lt;/code&gt;操作符表示逻辑或的关系，同样可以连接两个命令，如&lt;code&gt;cmd1 || cmd2&lt;/code&gt;，只有当&lt;code&gt;cmd1&lt;/code&gt;失败了，才会执行&lt;code&gt;cmd2&lt;/code&gt;，这里的失败指的是&lt;code&gt;cmd1&lt;/code&gt;的退出码非0。&lt;/p&gt;

&lt;h2 id=&#34;与-混合&#34;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;与&lt;code&gt;||&lt;/code&gt;混合&lt;/h2&gt;

&lt;p&gt;这两个操作符是可以混合使用的，其遵循的原则保持一致，且是从左向右依次判断，结合这两种操作符，可以实现类似于&lt;code&gt;if then else&lt;/code&gt;的逻辑结构。如&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2 || cmd3&lt;/code&gt;意思就是如果&lt;code&gt;cmd1&lt;/code&gt;成功，则执行&lt;code&gt;cmd2&lt;/code&gt;，否则执行&lt;code&gt;cmd3&lt;/code&gt;。但务必注意的是，此处并非真正意思上的&lt;code&gt;if then else&lt;/code&gt;逻辑，因为如果&lt;code&gt;cmd2&lt;/code&gt;也执行失败，&lt;code&gt;cmd3&lt;/code&gt;其实也会被执行。如下例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo hello &amp;amp;&amp;amp; echo ok || echo world
hello
ok
# echo hello &amp;amp;&amp;amp; rm dfsdf || echo world
hello
rm: cannot remove ‘dfsdf’: No such file or directory
world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;相当于将两条命令逻辑上连成了一条命令，这样就变成了&lt;code&gt;cmd1-2 || cmd3&lt;/code&gt;，其中&lt;code&gt;cmd1-2&lt;/code&gt;就是&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;，因此，&lt;code&gt;cmd3&lt;/code&gt;只要在&lt;code&gt;cmd1-2&lt;/code&gt;失败的情况下都会被执行，而&lt;code&gt;cmd1-2&lt;/code&gt;失败的情况有两种，一种是&lt;code&gt;cmd1&lt;/code&gt;失败，一种是&lt;code&gt;cmd1&lt;/code&gt;成功但是&lt;code&gt;cmd2&lt;/code&gt;失败。同样的，&lt;code&gt;||&lt;/code&gt;也会将两条命令连成一条命令，如&lt;code&gt;cmd1-2 || cmd3 &amp;amp;&amp;amp; cmd4&lt;/code&gt;就相当于&lt;code&gt;cmd1-2_3 &amp;amp;&amp;amp; cmd4&lt;/code&gt;，&lt;code&gt;cmd4&lt;/code&gt;是否会执行，决定于&lt;code&gt;cmd1-2_3&lt;/code&gt;是否失败，以具体例子说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo hello &amp;amp;&amp;amp; echo ok || echo world &amp;amp;&amp;amp; rm dsdfsf || echo end
hello
ok
rm: cannot remove ‘dsdfsf’: No such file or directory
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行命令相当于&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2 || cmd3 &amp;amp;&amp;amp; cmd4 || cmd5&lt;/code&gt;，可以看出&lt;code&gt;cmd1&lt;/code&gt;，&lt;code&gt;cmd2&lt;/code&gt;，&lt;code&gt;cmd4&lt;/code&gt;还是有&lt;code&gt;cmd5&lt;/code&gt;被执行了，而&lt;code&gt;cmd3&lt;/code&gt;没有执行。咱们来解析一下，为何是如此的执行结果。首先，&lt;code&gt;shell&lt;/code&gt;从左往右扫描执行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发现&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;，由&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;连成一个命令&lt;code&gt;cmd1-2&lt;/code&gt;，因为两个命令都是成功的，所以都被执行了，这样可以认为&lt;code&gt;cmd1-2&lt;/code&gt;成功&lt;/li&gt;
&lt;li&gt;执行成功之后，接下来是&lt;code&gt;||&lt;/code&gt;操作符，这里并不会因为前面的命令是成功的，而不再执行后面所有的命令，而是&lt;code&gt;||&lt;/code&gt;操作符相当于将&lt;code&gt;cmd1-2&lt;/code&gt;与&lt;code&gt;cmd3&lt;/code&gt;连接成了&lt;code&gt;cmd1-2_3&lt;/code&gt;，因为&lt;code&gt;cmd1-2&lt;/code&gt;成功了，所以&lt;code&gt;cmd3&lt;/code&gt;不再执行，但是&lt;code&gt;cmd1-2_3&lt;/code&gt;相当于执行成功了&lt;/li&gt;
&lt;li&gt;继续执行，发现是&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;操作符，同样将&lt;code&gt;cmd1-2_3&lt;/code&gt;与&lt;code&gt;cmd4&lt;/code&gt;连接起来，记为&lt;code&gt;cmd1-2_3-4&lt;/code&gt;，因为&lt;code&gt;cmd1-2_3&lt;/code&gt;执行成功了，所以&lt;code&gt;cmd4&lt;/code&gt;也被执行，但是&lt;code&gt;cmd4&lt;/code&gt;执行失败了，所以&lt;code&gt;cmd1-2_3-4&lt;/code&gt;相当于执行失败&lt;/li&gt;
&lt;li&gt;继续执行，发现是&lt;code&gt;||&lt;/code&gt;操作符，同样将&lt;code&gt;cmd1-2_3-4&lt;/code&gt;与&lt;code&gt;cmd5&lt;/code&gt;连成&lt;code&gt;cmd1-2_3-4_5&lt;/code&gt;，因为&lt;code&gt;cmd1-2_3-4&lt;/code&gt;执行失败，所以&lt;code&gt;cmd5&lt;/code&gt;被执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，&lt;code&gt;shell&lt;/code&gt;永远都是从左往右扫描执行，&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;跟&lt;code&gt;||&lt;/code&gt;会将前后两个命令连接起来，根据两种操作符的规则就可以知道多个连起来的命令是如何执行的了。&lt;/p&gt;

&lt;h2 id=&#34;符号-1&#34;&gt;&lt;code&gt;#&lt;/code&gt;符号&lt;/h2&gt;

&lt;p&gt;跟其它很多语言一样，&lt;code&gt;#&lt;/code&gt;在&lt;code&gt;shell&lt;/code&gt;里面用来注释。&lt;/p&gt;

&lt;h2 id=&#34;转义符号&#34;&gt;&lt;code&gt;\&lt;/code&gt;转义符号&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;\&lt;/code&gt;符号可以用来转义一些特殊符号，如&lt;code&gt;$&lt;/code&gt;，&lt;code&gt;#&lt;/code&gt;等。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;特别指出的是，如果转义符号放在行末单独使用，则用来连接下一行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;shell变量&#34;&gt;shell变量&lt;/h1&gt;

&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;

&lt;h3 id=&#34;定义跟引用&#34;&gt;定义跟引用&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;中也可以使用变量，变量不需要像其它语言一样需要预先申明。&lt;code&gt;shell&lt;/code&gt;中赋值给一个不存在的变量就相当于定义了变量，如&lt;code&gt;name=&amp;quot;Mr. Hao&amp;quot;&lt;/code&gt;，就定义了&lt;code&gt;name&lt;/code&gt;变量，后续如果再对&lt;code&gt;name&lt;/code&gt;赋值，就相当于改变改变量的值。与很多语言不同的是，&lt;code&gt;shell&lt;/code&gt;中变量引用以&lt;code&gt;$&lt;/code&gt;符号开头，后面跟变量的名字。如前面的变量，引用如下&lt;code&gt;echo &amp;quot;$name&amp;quot;&lt;/code&gt;。&lt;strong&gt;需要注意的是，在&lt;code&gt;shell&lt;/code&gt;中，变量名是大小写敏感的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;shell&lt;/code&gt;展开中会自动展开变量的引用，即便该变量处在双引号中。但是，如果变量引用在单引号中，&lt;code&gt;shell&lt;/code&gt;不会对其进行解析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# name=&amp;quot;Mr. Hao&amp;quot;
# echo &amp;quot;$name&amp;quot;
Mr. Hao
# set -x
# echo &#39;$name&#39;
+ echo &#39;Mr. Hao&#39;
$name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查找变量&#34;&gt;查找变量&lt;/h3&gt;

&lt;p&gt;可以使用&lt;code&gt;set&lt;/code&gt;命令来查找所定义的变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# set | grep -E &#39;^name=&#39;
name=&#39;Mr. Hao&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;删除变量&#34;&gt;删除变量&lt;/h3&gt;

&lt;p&gt;与很多语言不同的是，在&lt;code&gt;shell&lt;/code&gt;中定义的变量是可以删除的，使用&lt;code&gt;unset&lt;/code&gt;命令删除定义的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# set | grep -E &#39;^name=&#39;
name=&#39;Mr. Hao&#39;
# unset name
# set | grep -E &#39;^name=&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;export-声明&#34;&gt;&lt;code&gt;export&lt;/code&gt;声明&lt;/h3&gt;

&lt;p&gt;通常情况下，&lt;code&gt;shell&lt;/code&gt;在执行命令的时候会为该命令创建子进程。如果希望将当前的变量作用到子进程，则需要将变量&lt;code&gt;export&lt;/code&gt;声明，这种变量称之为环境变量，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=&amp;quot;hello&amp;quot;
# export var2=&amp;quot;world&amp;quot;
# bash
# echo &amp;quot;var1=$var1, var2=$var2&amp;quot;
var1=, var2=world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;bash&lt;/code&gt;命令开启了一个新的&lt;code&gt;shell&lt;/code&gt;，可见只有&lt;code&gt;export&lt;/code&gt;声明的变量在新的&lt;code&gt;shell&lt;/code&gt;中才是可见的。环境变量可以通过&lt;code&gt;env&lt;/code&gt;命令列举出来，在后面一节会详细讲述。此外，如果需要将非&lt;code&gt;export&lt;/code&gt;变量重新声明为&lt;code&gt;export&lt;/code&gt;变量，则只需要用&lt;code&gt;export&lt;/code&gt;重新声明一下即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=hello
# env | grep var1
# export var1
# env | grep var1
var1=hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;env-命令&#34;&gt;&lt;code&gt;env&lt;/code&gt;命令&lt;/h3&gt;

&lt;p&gt;如果需要查看当前&lt;code&gt;shell&lt;/code&gt;中有哪些&lt;code&gt;export&lt;/code&gt;声明的变量，可以使用&lt;code&gt;env&lt;/code&gt;命令，该命令会列出当前所有&lt;code&gt;export&lt;/code&gt;声明的变量。请注意与&lt;code&gt;set&lt;/code&gt;命令的区别，&lt;code&gt;set&lt;/code&gt;命令会列出所有的变量，包括哪些不是&lt;code&gt;export&lt;/code&gt;声明的变量。通常，我们把&lt;code&gt;env&lt;/code&gt;命令输出的变量称之为&lt;code&gt;环境变量&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此外，&lt;code&gt;env&lt;/code&gt;也常用来为子&lt;code&gt;shell&lt;/code&gt;预先定义一些临时变量，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=&amp;quot;hello&amp;quot;
# env var1=&amp;quot;tmp&amp;quot; bash -c &#39;echo &amp;quot;$var1&amp;quot;&#39;
tmp
# echo $var1
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，用&lt;code&gt;env&lt;/code&gt;命令定义了临时变量&lt;code&gt;var1&lt;/code&gt;，然后&lt;code&gt;bash&lt;/code&gt;命令开启了一个子&lt;code&gt;shell&lt;/code&gt;，并在子&lt;code&gt;shell&lt;/code&gt;中执行了&lt;code&gt;echo &amp;quot;$var1&amp;quot;&lt;/code&gt;命令。可见，输出了定义的临时变量，在命令结束后，又回到之前的&lt;code&gt;shell&lt;/code&gt;，输出的也是之前&lt;code&gt;shell&lt;/code&gt;中定义的值。当然，在使用&lt;code&gt;env&lt;/code&gt;定义临时变量的时候，为了方便，通常我们可以省略&lt;code&gt;env&lt;/code&gt;命令，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# var1=&amp;quot;hello&amp;quot;
# var1=&amp;quot;tmp&amp;quot; bash -c &#39;echo &amp;quot;$var1&amp;quot;&#39;
tmp
# echo $var1
hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，&lt;code&gt;env&lt;/code&gt;命令还有一种常用的用法，就是用来开启一个干净的子&lt;code&gt;shell&lt;/code&gt;，即在子&lt;code&gt;shell&lt;/code&gt;中不继承所有的变量，即便这些变量在之前的&lt;code&gt;shell&lt;/code&gt;中采用&lt;code&gt;export&lt;/code&gt;声明，此时&lt;code&gt;env&lt;/code&gt;命令需要加入&lt;code&gt;-i&lt;/code&gt;的参数，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# export var1=&amp;quot;hello world&amp;quot;
# bash -c &#39;echo &amp;quot;var1=$var1&amp;quot;&#39;
var1=hello world
# env -i bash -c &#39;echo &amp;quot;var1=$var1&amp;quot;&#39;
var1=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，使用&lt;code&gt;env -i&lt;/code&gt;之后，即便&lt;code&gt;var1&lt;/code&gt;被&lt;code&gt;export&lt;/code&gt;声明，但是在子&lt;code&gt;shell&lt;/code&gt;中也没有被继承。&lt;/p&gt;

&lt;h3 id=&#34;变量解释&#34;&gt;变量解释&lt;/h3&gt;

&lt;p&gt;在前面章节，我们知道&lt;code&gt;shell&lt;/code&gt;采用&lt;code&gt;$&lt;/code&gt;符号引用变量，在&lt;code&gt;$&lt;/code&gt;符号后紧跟变量的名字。而&lt;code&gt;shell&lt;/code&gt;在提取变量名字的时候一般以非字母数字（non-alphanumeric）为边界，这有时候就会产生问题，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# prefix=Super
# echo Hello $prefixman and $prefixgirl
Hello  and
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，&lt;code&gt;shell&lt;/code&gt;并不能提取我们定义的变量&lt;code&gt;prefix&lt;/code&gt;，因为其后并没有非字母数字的字符为界。这种情况下，我们可以使用&lt;code&gt;{}&lt;/code&gt;将变量名保护起来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# prefix=Super
# echo Hello ${prefix}man and ${prefix}girl
Hello Superman and Supergirl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;非绑定-unbound-变量&#34;&gt;非绑定（unbound）变量&lt;/h3&gt;

&lt;p&gt;所谓非绑定（unbound）变量其实指的是没有预先定义的变量，或者说不存在的变量。默认情况下，&lt;code&gt;shell&lt;/code&gt;在解释这种变量的时候会以空字符串替代：&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h1 id=&#34;echo-unbound-var&#34;&gt;echo $unbound_var&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;
如果需要`shell`在这种情况下报错，可以配置`shell`选项`set -o nounset`，或者简写为`set -u`：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;echo-unbound-var-1&#34;&gt;echo $unbound_var&lt;/h1&gt;

&lt;p&gt;bash: unbound_var: unbound variable&lt;/p&gt;

&lt;h1 id=&#34;set-u&#34;&gt;set +u&lt;/h1&gt;

&lt;h1 id=&#34;echo-unbound-var-2&#34;&gt;echo $unbound_var&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;
当然，由例子中可以看到，要取消该配置，可以相应的设置`set +o nounset`，或者简写为`set +u`。

## 特殊变量

在`shell`中预定义了很多特殊的变量，这一节咱们来说一下常见的几个变量。

### `$PS1`变量

在`shell`终端输入命令时，咱们总是可以看到在输入行首总是会有提示符，如：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mrhao:~$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其中，`mrhao:~$ `就是提示符，这个字串实际上是由`shell`变量`$PS1`决定的。如果咱们改变一下该变量的值，提示符也会相应的改变：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mrhao:~$ PS1=&amp;ldquo;hello &amp;gt; &amp;ldquo;
hello &amp;gt; echo &amp;ldquo;PS1 value is &amp;lsquo;$PS1&amp;rsquo;&amp;rdquo;
PS1 value is &amp;lsquo;hello &amp;gt; &amp;lsquo;
hello &amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
为了方便在提示符中显示系统的某些实时信息，`$PS1`变量定义了一些特殊的字符：

| 字符 | 说明               |
|------|--------------------|
| \w   | 表示工作目录       |
| \u   | 表示用户名         |
| \h   | 表示系统的hostname |

当然，这里只列举了几个，详细的可以查看Linux手册。另外，`$PS1`中还可以对对其中不同部分采用不同颜色显示，如：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;red-033-01-31m&#34;&gt;RED=&amp;rsquo;[\033[01;31m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;white-033-01-00m&#34;&gt;WHITE=&amp;rsquo;[\033[01;00m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;green-033-01-32m&#34;&gt;GREEN=&amp;rsquo;[\033[01;32m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;blue-033-01-34m&#34;&gt;BLUE=&amp;rsquo;[\033[01;34m]&amp;lsquo;&lt;/h1&gt;

&lt;h1 id=&#34;ps1-green-u-white-blue-h-white-w&#34;&gt;PS1=&amp;ldquo;$GREEN\u$WHITE@$BLUE\h$WHITE\w\$ &amp;ldquo;&lt;/h1&gt;

&lt;p&gt;mrhao@mrhao-host~$ echo &amp;ldquo;$PS1&amp;rdquo;
[\033[01;32m]\u[\033[01;00m]@[\033[01;34m]\h[\033[01;00m]\w$&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
### `$PATH`变量

当我们在Linux的terminal里面输入命令的时候，`shell`需要在一系列的目录中查找输入的命令，如果没有查找到会直接报`command not found`的错误。而这些查找的目录就定义在`$PATH`变量中。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;echo-path&#34;&gt;echo $PATH&lt;/h1&gt;

&lt;p&gt;/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其中，每个目录以`:`隔开，如果需要增加目录，可以：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;path-path-opt-local-bin&#34;&gt;PATH=$PATH:/opt/local/bin&lt;/h1&gt;

&lt;h1 id=&#34;echo-path-1&#34;&gt;echo $PATH&lt;/h1&gt;

&lt;p&gt;/opt/rh/rh-python34/root/usr/bin:/usr/java/default/bin/:/usr/local/git/bin:/opt/ActiveTcl-8.5/bin:/root/perl5/bin:/root/env/maven/apache-maven-3.3.3/bin:/root/soft/wrk/wrk-4.0.1:/root/usr/go/bin:/usr/local/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/opt/local/bin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&amp;gt; 加入新的路径的时候请务必带上之前的路径，`$PATH:&amp;lt;new path&amp;gt;`否则，很多默认的系统路径将被覆盖，导致很多命令失效。

特别注意的是，`$PATH`变量中目录的顺序是很重要的，如果`shell`在前面的目录中找到了命令，则不会查找后面的目录。如果你想把某个重名的命令优先执行，就需要把它对应的目录放在`$PATH`的前面。

### 网络代理变量

在Linux系统中，很多时候我们需要访问外部网络，比如使用`curl`命令下载文件等等。而有的时候，访问访问外部网络咱们需要设置代理，在Linux系统中，使用网络代理非常简单，只要配置几个变量即可：

| 变量        | 说明                                                                    |
|-------------|-------------------------------------------------------------------------|
| http_proxy  | 设置访问`http`请求所需要的代理，如`http_proxy=http://10.10.10.100:80`   |
| https_proxy | 设置访问`https`请求所需要的代理，如`https_proxy=http://10.10.10.100:80` |
| ftp_proxy   | 设置访问`ftp`请求所需要的代理，如`ftp_proxy=http://10.10.10.100:80`     |
| no_proxy    | 设置哪些域名或者IP不需要走代理，如`no_proxy=localhost,127.0.0.1`        |

### `$PWD`变量

`PWD`变量是一个由`shell`自动设置的变量，其值表示当前目录的绝对路径，与命令`pwd`输出相同。

# `shell`嵌入与`shell`选项

## `shell`嵌入（shell embedding）

`shell`可以嵌入在同一个命令行中，也就是`shell`在扫描解释命令行的时候，可能会从当前的`shell`进程中`fork`出一个新的`shell`进程，并将有关命令放在新进程中运行。如下例：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;var1-hello&#34;&gt;var1=hello&lt;/h1&gt;

&lt;h1 id=&#34;echo-var1-world-echo-var1&#34;&gt;echo $(var1=world; echo $var1)&lt;/h1&gt;

&lt;p&gt;world&lt;/p&gt;

&lt;h1 id=&#34;echo-var1&#34;&gt;echo $var1&lt;/h1&gt;

&lt;p&gt;hello&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
如其中`$()`便开启了一个新的`shell`进程，或者成为子`shell`，并在此`shell`中运行命令`var1=world; echo $var1`，此时输出的是子`shell`中定义的`var1`。当命令结束后，子`shell`进程退出，并将输出的结果`world`返回给之前的`shell`（或者父`shell`）的`echo`命令，父`shell`最后输出`world`。而且，在子`shell`中定义相同的`var1`变量并不会改变父`shell`中的变量。

***特别注意的是，因为子`shell`是`fork`出来的进程，根据Linux进程`fork`的特点，子进程将共享父进程的数据空间，而只在写的时候拷贝新的数据空间，因此，创建出来的子`shell`是会继承所有父`shell`的变量，不论该变量是否被`export`声明***

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;var1-hello-1&#34;&gt;var1=hello&lt;/h1&gt;

&lt;h1 id=&#34;var2-echo-var1-world&#34;&gt;var2=&amp;ldquo;$(echo $var1 world)&amp;rdquo;&lt;/h1&gt;

&lt;h1 id=&#34;echo-var2&#34;&gt;echo $var2&lt;/h1&gt;

&lt;p&gt;hello world&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
可见，虽然`var1`变量没有`export`声明，但是在子`shell`中还是可见的。这点与使用`bash -c`开启的`shell`是不同的。

用`$()`可以将子`shell`嵌入到命令行中，当然，`$()`是可以嵌套使用的，这样可以用来在子`shell`中开启它的子`shell`。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;a-shell&#34;&gt;A=shell&lt;/h1&gt;

&lt;h1 id=&#34;echo-c-b-a-b-sub-echo-c-b-a-echo-c-sub-echo-c-b-a&#34;&gt;echo $C$B$A $(B=sub;echo $C$B$A; echo $(C=sub;echo $C$B$A))&lt;/h1&gt;

&lt;p&gt;shell subshell subsubshell&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
### 反引号（backticks）

在上面我们可以通过`$()`将子`shell`嵌入命令行中，为了方便，我们同样可以用反引号`` ` ``将子`shell`嵌入。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;var1-hello-2&#34;&gt;var1=hello&lt;/h1&gt;

&lt;h1 id=&#34;echo-var1-world-echo-var1-1&#34;&gt;echo &lt;code&gt;var1=world; echo $var1&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;world&lt;/p&gt;

&lt;h1 id=&#34;echo-var1-1&#34;&gt;echo $var1&lt;/h1&gt;

&lt;p&gt;hello&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
但是，使用反引号不能够嵌套子`shell`，因此如果需要嵌套子`shell`时，只能使用`$()`。

&amp;gt; 反引号跟单引号是本质的不同的，单引号与双引号一样，用来将连续的字串作为整体引起来，只不过单引号中将不执行变量的引用解析，而反引号则是嵌入子`shell`。


## `shell`选项

其实在前面咱们已经使用了不少`shell`的选项，如`set -u`在变量不存在是报错，`set -x`将`shell`展开的结果显示出来等。此外，可以才用`echo $-`将当期设置的`shell`选项打印出来。

# `shell`历史记录

在`shell`中执行命令的时候，`shell`会将最近的命令使用历史记录下来，这样你可以很方便的查看最近做了什么操作。

## 查看历史记录

命令`history`可以用来查看`shell`的历史记录，里面记录了你最近输入的所有命令。当然，很多时候你更加关心最近的几个命令，你可以使用`history 10`来显示最近的10个命令。另外，`shell`通常还会将最近的历史记录写在`~/.bash_history`文件中，因此查看该文件同样可以查看历史记录。

## 执行历史的命令

`shell`提供了很多高级用法使得你可以很方便的执行以前执行过的命令。

首先，咱们先显示一下过去的10个命令，可以看到每个命令前面都有其对应的序号。

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;history-10&#34;&gt;history 10&lt;/h1&gt;

&lt;p&gt;1000  history
 1001  history 10
 1002  echo &amp;ldquo;hello world&amp;rdquo;
 1003  ls -l
 1004  ps -ef | grep named
 1005  env | grep http
 1006  grep hello /var/log/messages
 1007  tmux ls
 1008  find . -name &amp;ldquo;hello&amp;rdquo;
 1009  history 10&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
下面列举比较常用的`shell`重复执行历史记录中命令的方法：

| 命令      | 说明                                                                                                  |
|-----------|-------------------------------------------------------------------------------------------------------|
| !!        | 在`shell`中输入两个感叹号会执行上一个命令                                                             |
| !keyword  | 输入一个感叹号后跟关键字，会搜索历史记录中最先以该关键字开始的命令。如`!find`会执行序号为1008的命令。 |
| !?keyword | 执行历史记录中第一个包括keyword关键字的命令                                                           |
| !n        | 其中n代表历史记录中的序号，表示执行序号为n的命令。                                                    |
| !-n       | 执行倒数第n个命令，如`!-1`其实就相当于`!!`                                                            |
| cmd!*     | 执行命令`cmd`，其中`!*`会以上一条命令的所有参数替代                                                   |

另外，对于`!keyword`的用法，还有一个高级功能，你可以将符合该条件的命令进行改造后执行，如：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;echo-test1&#34;&gt;echo &amp;ldquo;test1&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;test1&lt;/p&gt;

&lt;h1 id=&#34;ec-s-1-2&#34;&gt;!ec:s/1/2/&lt;/h1&gt;

&lt;p&gt;echo &amp;ldquo;test2&amp;rdquo;
test2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
其中，`:s/1/2/`将命令`echo &amp;quot;test1&amp;quot;`替换成`echo &amp;quot;test2&amp;quot;`然后执行了。对于`cmd!*`，示例如下：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ctt-etc-passwd-cut-d-f1&#34;&gt;ctt /etc/passwd | cut -d: -f1&lt;/h1&gt;

&lt;p&gt;-bash: ctt: command not found&lt;/p&gt;

&lt;h1 id=&#34;cat&#34;&gt;cat !*&lt;/h1&gt;

&lt;p&gt;cat /etc/passwd | cut -d: -f1
root
bin
daemon
adm
&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
## 搜索历史记录

在`shell`终端中按Ctrl-r会打开`shell`的搜索模式，在改模式下输入关键字会显示最近包含改关键字的命令，再按一下Ctrl-r会继续显示前面一条符合条件的命令，找到你需要的命令后回车就可以执行改命令了。

## 修改历史记录的有关配置

有多个配置可以用来改变历史记录的有关信息，通常都是通过有关环境变量来配置：

| 环境变量      | 说明                                                                                       |
|---------------|--------------------------------------------------------------------------------------------|
| $HISTSIZE     | 这个变量用来配置`shell`应该保持多少行的历史记录，在很多发行版本中，默认值一般为500或者1000 |
| $HISTFILE     | 这个变量用来配置历史记录文件存放的位置，通常来讲，默认路径为`~/.bash_history`              |
| $HISTFILESIZE | 这个变量用来配置历史记录文件可以存放多少行的历史记录                                       |

## 阻止记录某些命令

在有些时候，我们并不想把某些命令记录在历史记录中，比如有的命令里面包括了敏感信息如密码等。在新版本的`shell`中，通常我们可以在输入的命令前面加入空格，这样`shell`就不会记录这样的命令，当然，如果你的发行版本默认并不支持，你可以配置环境变量来打开这个功能：

```sh
export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# history 5
 1023  ls -l
 1024  echo &amp;quot;&amp;quot;
 1025  history 5
 1026  ls
 1027  history 5
#  echo &amp;quot;password=123456&amp;quot;
password=123456
# history 5
 1025  history 5
 1026  ls
 1027  history 5
 1028   echo &amp;quot;password=123456&amp;quot;
 1029  history 5
# export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
# history 5
 1027  history 5
 1028   echo &amp;quot;password=123456&amp;quot;
 1029  history 5
 1030  export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
 1031  history 5
#  echo &amp;quot;password=123456&amp;quot;
password=123456
# history 5
 1027  history 5
 1028   echo &amp;quot;password=123456&amp;quot;
 1029  history 5
 1030  export HISTIGNORE=&amp;quot;[ \t]*&amp;quot;
 1031  history 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，在设置&lt;code&gt;$HISTIGNORE&lt;/code&gt;变量之后，在前面加了空格的命令将不再记录。这在保护敏感信息的时候非常有用。&lt;/p&gt;

&lt;h1 id=&#34;文件匹配-file-globbing&#34;&gt;文件匹配(File Globbing)&lt;/h1&gt;

&lt;p&gt;文件匹配(File Globbing)又成为动态文件名生成，用它可以非常方便的在&lt;code&gt;shell&lt;/code&gt;中输入文件名。&lt;/p&gt;

&lt;h2 id=&#34;星号&#34;&gt;&lt;code&gt;*&lt;/code&gt;星号&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;星号在&lt;code&gt;shell&lt;/code&gt;中用来匹配任意数量的字符，比如文件名&lt;code&gt;File*.mp4&lt;/code&gt;，将匹配以&lt;code&gt;File&lt;/code&gt;开头，&lt;code&gt;.mp4&lt;/code&gt;结尾的任何文件名。&lt;code&gt;shell&lt;/code&gt;在扫描解释命令的时候会自动去查找符合该匹配的所有文件或目录。当然，你也可以只用&lt;code&gt;*&lt;/code&gt;来匹配所有的文件及目录，但请注意，只使用&lt;code&gt;*&lt;/code&gt;跟不带&lt;code&gt;*&lt;/code&gt;还是有所区别的，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls
definition.yaml  example  __init__.py  tags.yaml  test.py  test_sample.html  test_sample.py
# ls *
definition.yaml  __init__.py  tags.yaml  test.py  test_sample.html  test_sample.py

example:
testcase
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，带上&lt;code&gt;*&lt;/code&gt;后不仅把当前目录的所有文件及目录显示出来，而且还把目录下的内容显示出来了。&lt;/p&gt;

&lt;h2 id=&#34;问号&#34;&gt;&lt;code&gt;?&lt;/code&gt;问号&lt;/h2&gt;

&lt;p&gt;问号用来匹配一个字符，如&lt;code&gt;File?.mp4&lt;/code&gt;可以匹配&lt;code&gt;File1.mp4&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;方括号&#34;&gt;&lt;code&gt;[]&lt;/code&gt;方括号&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;[]&lt;/code&gt;方括号也用来匹配一个字符，但是在括号里面可以指定一个字符集用来限定匹配的字符必须在该字符集内，字符集里面的字符顺序没有关系。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls
file1  file2  file3  File4  File55  FileA  fileab  Fileab  FileAB  fileabc
# ls File[5A]
FileA
# ls File[A5]
FileA
# ls File[A5][5b]
File55
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要匹配不在某个字符集里面的字符，可以在&lt;code&gt;[]&lt;/code&gt;第一个字符加入&lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls file[!5]*
file1  file2  file3  fileab  fileabc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特别的，为了方便，&lt;code&gt;[]&lt;/code&gt;中可以使用&lt;code&gt;-&lt;/code&gt;来定义一些连续的字符集（Range匹配），常用的这类字符集包括：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符集&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0-9&lt;/td&gt;
&lt;td&gt;表示数字字符集&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;a-z&lt;/td&gt;
&lt;td&gt;表示小写字母字符集&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;A-Z&lt;/td&gt;
&lt;td&gt;表示大写字母字符集&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当然，你也不必要把所有范围都包括在内，如&lt;code&gt;[a-d]&lt;/code&gt;可以用来限定从&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;d&lt;/code&gt;的小写字母集。另外，用&lt;code&gt;-&lt;/code&gt;连起来的字符集还可以跟其它字符集一起使用，如&lt;code&gt;[a-d_]&lt;/code&gt;表示&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;d&lt;/code&gt;的小写字母加上&lt;code&gt;_&lt;/code&gt;所组成的字符集。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Range匹配的大小写问题&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;[]&lt;/code&gt;的Range匹配，还有一点很重要。在很多发行版本中，默认情况下，&lt;code&gt;[]&lt;/code&gt;的Range匹配是忽略大小写的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ls
Test1  test2
# ls [a-z]*
Test1  test2
# ls [A-Z]*
Test1  test2
# ls [t]*
test2
# ls [T]*
Test1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，是&lt;code&gt;[]&lt;/code&gt;的Range匹配会忽略大小写，而如果不是Range匹配还是大小写敏感的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; # ls
&amp;gt; Test1  test2
&amp;gt; # ls [T]*
&amp;gt; Test1
&amp;gt; # ls [t]*
&amp;gt; test2
&amp;gt; ```

如果需要大小写敏感，可以设置环境变量`LC_ALL`：

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lc-all-c&#34;&gt;LC_ALL=C&lt;/h1&gt;

&lt;h1 id=&#34;ls-a-z&#34;&gt;ls [a-z]*&lt;/h1&gt;

&lt;p&gt;test2&lt;/p&gt;

&lt;h1 id=&#34;ls-a-z-1&#34;&gt;ls [A-Z]*&lt;/h1&gt;

&lt;p&gt;Test1
```&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然，请务必注意，&lt;code&gt;LC_ALL&lt;/code&gt;的会改变当前的语言环境，还请慎重使用，建议只在临时的子&lt;code&gt;shell&lt;/code&gt;中使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;阻止文件匹配-file-globbing&#34;&gt;阻止文件匹配(File Globbing)&lt;/h2&gt;

&lt;p&gt;有时候我们就是需要输出&lt;code&gt;*&lt;/code&gt;等匹配符号，这个时候就需要阻止&lt;code&gt;shell&lt;/code&gt;做相应的匹配。可以使用转义符号&lt;code&gt;\&lt;/code&gt;来做到这点，或者将匹配符号放在引号中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo *
Test1 test2
# echo \*
*
# echo &#39;*&#39;
*
# echo &amp;quot;*&amp;quot;
*
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;shell快捷键&#34;&gt;shell快捷键&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;中支持非常多的快捷键，可以非常方便我们输入命令：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl-d&lt;/td&gt;
&lt;td&gt;表示&lt;code&gt;EOF&lt;/code&gt;的意思，在shell终端中输入该快捷键会退出该终端&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-z&lt;/td&gt;
&lt;td&gt;该快捷键用来暂停一个在shell终端中正在执行的进程，暂停后可以用&lt;code&gt;fg&lt;/code&gt;命令恢复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-a&lt;/td&gt;
&lt;td&gt;输入命令时跳到行首&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-e&lt;/td&gt;
&lt;td&gt;跳到行尾&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-k&lt;/td&gt;
&lt;td&gt;删除从光标到行尾的部分&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-y&lt;/td&gt;
&lt;td&gt;粘贴刚刚删除的部分&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ctrl-w&lt;/td&gt;
&lt;td&gt;删除从光标至其左边第一个空格处&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（一）命令行</title>
      <link>https://keysaim.github.io/post/linux/2017-10-09-linux-study-command-line/</link>
      <pubDate>Mon, 09 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-09-linux-study-command-line/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;随着Linux的发展，现在已经有了非常多的桌面版本，比如著名的Ubuntu。用这些桌面版本系统，可以满足基本的操作，然而对于一些高级点的操作，还是离不开Linux的命令行(Command Line)。而Linux的精髓也更多的体现在命令行上，其强大的功能，海量的工具，可以帮你轻而易举的完成各种复杂的系统管理操作。本文将详细讲述Linux命令行。&lt;/p&gt;

&lt;h1 id=&#34;基础命令&#34;&gt;基础命令&lt;/h1&gt;

&lt;h2 id=&#34;帮助类&#34;&gt;帮助类&lt;/h2&gt;

&lt;h3 id=&#34;man&#34;&gt;man&lt;/h3&gt;

&lt;p&gt;Linux有着海量的命令，而每个命令又有很多的不同参数，要记住所有的这些命令是比较困难的，因此，在使用Linux命令行的时候，必须时刻记着查看Linux的帮助，而查看帮助就是采用&lt;code&gt;man&lt;/code&gt;命令。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看命令帮助&lt;/p&gt;

&lt;p&gt;以&lt;code&gt;ls&lt;/code&gt;命令为例，如果要查看帮助的话可以输入&lt;code&gt;man ls&lt;/code&gt;，查看基本的帮助信息也可以直接&lt;code&gt;ls --help&lt;/code&gt;。其将以分页的形式显示该命令的完整文档，操作该文档的基本命令有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按&lt;code&gt;u&lt;/code&gt;上翻页&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;d&lt;/code&gt;下翻页&lt;/li&gt;
&lt;li&gt;按空格下翻页&lt;/li&gt;
&lt;li&gt;按回车下移一行&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;/&lt;/code&gt;进入搜索模式，输入要搜索的关键字，按回车搜索。&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;n&lt;/code&gt;搜索下一个&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;N&lt;/code&gt;搜索上一个&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;q&lt;/code&gt;退出查看&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看配置文件的帮助&lt;/p&gt;

&lt;p&gt;有些系统的配置文件也同样有对应的帮助文档，可以通过&lt;code&gt;man $configfile&lt;/code&gt;来查看，比如&lt;code&gt;/etc/system/sysctl.conf&lt;/code&gt;配置文件，查看其帮助可以采用命令&lt;code&gt;man sysctl.conf&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看后台进程(daemon)的帮助&lt;/p&gt;

&lt;p&gt;Linux在后台运行着很多的程序（称为daemon），如果需要查看某个daemon的帮助，可以用命令&lt;code&gt;man $daemon&lt;/code&gt;来查看。如&lt;code&gt;man ntpd&lt;/code&gt;将查看时间同步daemon的帮助文档。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;搜索需要查看的命令&lt;/p&gt;

&lt;p&gt;Linux命令实在太多，有时候如果不记得准确的命令的名字，可以采用&lt;code&gt;man -k $keyword&lt;/code&gt;来搜索，如&lt;code&gt;man -k syslog&lt;/code&gt;将列出相关命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# man -k syslog
ipmievd (8)          - IPMI event daemon for sending events to syslog
logger (1)           - a shell command interface to the syslog(3) system log module
rsyslog.conf (5)     - rsyslogd(8) configuration file
rsyslogd (8)         - reliable and extended syslogd
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;whatis&#34;&gt;whatis&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt;命令将展示完整的文档，可以通过&lt;code&gt;whatis&lt;/code&gt;来查看命令的简单介绍。&lt;/p&gt;

&lt;h3 id=&#34;whereis&#34;&gt;whereis&lt;/h3&gt;

&lt;p&gt;如果需要知道某个命令的完整路径，可以采用&lt;code&gt;whereis $command&lt;/code&gt;来查看。&lt;/p&gt;

&lt;h2 id=&#34;目录操作类&#34;&gt;目录操作类&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;查看当前目录路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd $path&lt;/td&gt;
&lt;td&gt;切换到其它路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd ~&lt;/td&gt;
&lt;td&gt;返回home目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd ..&lt;/td&gt;
&lt;td&gt;返回上一级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd -&lt;/td&gt;
&lt;td&gt;返回上一次的目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ls $path&lt;/td&gt;
&lt;td&gt;查看目录下的内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ls -a&lt;/td&gt;
&lt;td&gt;显示目录下所有文件，包括隐藏文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ls -lh&lt;/td&gt;
&lt;td&gt;列表的形式显示，&lt;code&gt;-h&lt;/code&gt;以可读的方式显示大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建目录，要递归创建采用&lt;code&gt;mkdir -p&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;文件操作类&#34;&gt;文件操作类&lt;/h2&gt;

&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;大小写敏感
在Linux系统中，文件名都是大小写敏感的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所有都是文件
Linux基本上将文件，目录，设备等等都视为文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;file命令&#34;&gt;file命令&lt;/h3&gt;

&lt;p&gt;查看文件的类型，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file bugs.tgz
bugs.tgz: gzip compressed data, from Unix, last modified: Tue Dec 13 01:38:27 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以显示文件的类型及修改时间等信息。查看特殊文件如设备文件的时候，还可以带上&lt;code&gt;-s&lt;/code&gt;的参数，这样可以识别更多的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file /dev/sda
/dev/sda: block special
# file -s /dev/sda
/dev/sda: x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 1024000 sectors; partition 2: ID=0x8e, starthead 221, startsector 1026048, 208689152 sectors, code offset 0x63
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;touch&#34;&gt;touch&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;touch&lt;/code&gt;用来创建空文件，或者用来更新文件时间为当前时间。如果加上&lt;code&gt;-t&lt;/code&gt;参数，可以为文件设置指定的时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# date
Mon Oct  9 03:19:24 EDT 2017
# ls -l
total 4
-rw-r--r--. 1 root root 6 Jun 19  2016 login.html
# touch test.txt
# ls -l
total 4
-rw-r--r--. 1 root root 6 Jun 19  2016 login.html
-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt
# touch login.html
# ls -l
total 4
-rw-r--r--. 1 root root 6 Oct  9 03:19 login.html
-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt
# touch -t 201701011010 login.html
# ls -l
total 4
-rw-r--r--. 1 root root 6 Jan  1  2017 login.html
-rw-r--r--. 1 root root 0 Oct  9 03:19 test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;删除-复制-移动&#34;&gt;删除、复制、移动&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rm&lt;/td&gt;
&lt;td&gt;永久删除一个文件，对于此命令，没有所谓的垃圾箱，请慎重&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rm -i&lt;/td&gt;
&lt;td&gt;询问是否真的要删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rm -rf&lt;/td&gt;
&lt;td&gt;通常&lt;code&gt;rm&lt;/code&gt;只是删除文件，如果需要删除目录的时候，必须带上&lt;code&gt;-r&lt;/code&gt;参数，&lt;code&gt;-f&lt;/code&gt;参数表示强制删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cp&lt;/td&gt;
&lt;td&gt;拷贝文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cp -rf&lt;/td&gt;
&lt;td&gt;拷贝目录下所有的文件，并强制覆盖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mv&lt;/td&gt;
&lt;td&gt;移动文件到另一个目录，或者在当前目录下对某个文件改名字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;文件内容操作类&#34;&gt;文件内容操作类&lt;/h2&gt;

&lt;h3 id=&#34;head&#34;&gt;head&lt;/h3&gt;

&lt;p&gt;查看某个文件的头几行，可以用&lt;code&gt;head&lt;/code&gt;命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# head -n 5 /var/log/messages
Oct  9 03:10:01 traffic-base1 rsyslogd: [origin software=&amp;quot;rsyslogd&amp;quot; swVersion=&amp;quot;7.4.7&amp;quot; x-pid=&amp;quot;697&amp;quot; x-info=&amp;quot;http://www.rsyslog.com&amp;quot;] rsyslogd was HUPed
Oct  9 03:20:01 traffic-base1 systemd: Started Session 79213 of user root.
Oct  9 03:20:01 traffic-base1 systemd: Starting Session 79213 of user root.
Oct  9 03:28:26 traffic-base1 puppet-agent[14530]: Unable to fetch my node definition, but the agent run will continue:
Oct  9 03:28:26 traffic-base1 puppet-agent[14530]: Connection refused - connect(2)
# head -c 5 /var/log/messages
Oct  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;-n&lt;/code&gt;参数表示显示多少行，不带此参数，默认显示10行。&lt;code&gt;-c&lt;/code&gt;表示显示多少个字符，这里显示了前面5个字符。&lt;/p&gt;

&lt;h3 id=&#34;tail&#34;&gt;tail&lt;/h3&gt;

&lt;p&gt;与&lt;code&gt;head&lt;/code&gt;相反，&lt;code&gt;tail&lt;/code&gt;用来显示文件最后几行。同样&lt;code&gt;-n&lt;/code&gt;可以用来限制多少行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tail&lt;/code&gt;有个非常重要的用处，&lt;strong&gt;&lt;em&gt;就是用来监听某个动态文件的内容，比如实时查看某个日志文件&lt;/em&gt;&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# tail -n 5 -F /var/log/messages
Oct  9 03:28:27 traffic-base1 puppet: from /usr/share/ruby/vendor_ruby/puppet/util/command_line.rb:146:in `run&#39;
Oct  9 03:28:27 traffic-base1 puppet: from /usr/share/ruby/vendor_ruby/puppet/util/command_line.rb:92:in `execute&#39;
Oct  9 03:28:27 traffic-base1 puppet: from /usr/bin/puppet:8:in `&amp;lt;main&amp;gt;&#39;
Oct  9 03:30:01 traffic-base1 systemd: Started Session 79218 of user root.
Oct  9 03:30:01 traffic-base1 systemd: Starting Session 79218 of user root.
Oct  9 03:40:01 traffic-base1 systemd: Started Session 79223 of user root.
Oct  9 03:40:01 traffic-base1 systemd: Starting Session 79223 of user root.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它将不停的侦听文件的改变，并实时的将最后新写入的行打印出来。&lt;/p&gt;

&lt;h3 id=&#34;cat-file1-file2-file3&#34;&gt;cat $file1 $file2 $file3 &amp;hellip;&lt;/h3&gt;

&lt;p&gt;要显示文件的所有内容，可以用&lt;code&gt;cat&lt;/code&gt;命令。&lt;code&gt;cat&lt;/code&gt;也可以用来创建新文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;gt; test.txt
Today is a good day!
# cat test.txt
Today is a good day!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以直接输入文件内容了，输入完成之后按Ctrl+d结束输入。当然，也可以定制结束符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# cat &amp;gt; test.txt &amp;lt;&amp;lt;stop
&amp;gt; It&#39;s a good day!
&amp;gt; stop
# cat test.txt
It&#39;s a good day!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tac&#34;&gt;tac&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tac&lt;/code&gt;名字其实就是&lt;code&gt;cat&lt;/code&gt;倒过来写，所以其作用也是一样，就是把文件以倒着的顺序显示出来。&lt;/p&gt;

&lt;h3 id=&#34;more跟less&#34;&gt;more跟less&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;会直接把整个文件一次性的显示出来，当文件较大时，显示可能会刷屏，这样不利于查看。如果需要以翻页的形式显示文件的内容，可以采用&lt;code&gt;more&lt;/code&gt;或者&lt;code&gt;less&lt;/code&gt;命令，其查看方式跟&lt;code&gt;man&lt;/code&gt;命令的查看方式类似，可以参考前面的说明。&lt;/p&gt;

&lt;h3 id=&#34;strings&#34;&gt;strings&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;strings&lt;/code&gt;命令会将文件中的可读字符显示出来，即便改文件是一个二进制文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# strings a.out | tail -n 5
_edata
_Znwm@@GLIBCXX_3.4
_ZN3Out5InnerC1EPS_
main
_init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;code&gt;a.out&lt;/code&gt;是一个二进制文件。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍（二）文件系统结构</title>
      <link>https://keysaim.github.io/post/linux/2017-10-09-linux-study-file-system-hierarchy/</link>
      <pubDate>Mon, 09 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-09-linux-study-file-system-hierarchy/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;多数Linux发行版本都是遵循&lt;code&gt;文件系统结构标准（Filesystem Hierarchy Standard, 简称FHS）&lt;/code&gt;，可以在&lt;a href=&#34;http://www.pathname.com/fhs/&#34;&gt;这里&lt;/a&gt;找到该标准。本文对Linux的文件系统结构进行简单的介绍。&lt;/p&gt;

&lt;h1 id=&#34;根目录&#34;&gt;根目录&lt;code&gt;/&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;所有的Linux系统都有根目录，由&lt;code&gt;/&lt;/code&gt;表示。Linux系统的所有内容都在该目录下。&lt;/p&gt;

&lt;h1 id=&#34;二进制目录&#34;&gt;二进制目录&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/bin&lt;/td&gt;
&lt;td&gt;包括了可执行的二进制文件，通常这些二进制文件可以被所有用户访问。FHS规定，该目录至少包括&lt;code&gt;/bin/cat&lt;/code&gt;跟&lt;code&gt;/bin/date&lt;/code&gt;文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/sbin&lt;/td&gt;
&lt;td&gt;包括了系统的二进制文件，通过需要root权限，用来配置系统&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/lib&lt;/td&gt;
&lt;td&gt;包括了&lt;code&gt;/bin&lt;/code&gt;所依赖的库&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/lib/modules&lt;/td&gt;
&lt;td&gt;Linux将从&lt;code&gt;/lib/modules/$kernel-version/&lt;/code&gt;目录下载入内核模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/lib32和/lib64&lt;/td&gt;
&lt;td&gt;顾名思义，分别存放不同位数的库&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/opt&lt;/td&gt;
&lt;td&gt;该目录用来存放一些可选的软件，通常情况下，很多第三方的客户软件会选择安装在该目录下&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;配置文件目录&#34;&gt;配置文件目录&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boot&lt;/td&gt;
&lt;td&gt;顾名思义，用来存放系统启动的配置文件，如grub引导的配置文件&lt;code&gt;/boot/grub/grub.cfg&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc&lt;/td&gt;
&lt;td&gt;几乎大部分配置文件都放在改目录下。历史上&lt;code&gt;etc&lt;/code&gt;的全称是&lt;code&gt;etcetera&lt;/code&gt;，不过，现在一般认为是&lt;code&gt;Editable Text Configuration&lt;/code&gt;的缩写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc/init.d&lt;/td&gt;
&lt;td&gt;存放daemon启动、停止等的脚本文件。不过在引入systemd之后，启动脚本有所变化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc/skel&lt;/td&gt;
&lt;td&gt;存放创建新用户之后所需的配置文件的模板，如&lt;code&gt;.bashrc&lt;/code&gt;文件，默认会从该目录拷贝到用户目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc/sysconfig&lt;/td&gt;
&lt;td&gt;一般出现在RedHat系列的Linux系统中，存放系统有关配置，如IP的配置文件等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;数据目录&#34;&gt;数据目录&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;当创建一个新用户的时候，默认情况下，系统会为用户创建一个&lt;code&gt;/home/&amp;lt;username&amp;gt;&lt;/code&gt;的目录用来存放个人数据。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/root&lt;/td&gt;
&lt;td&gt;该目录被很多Linux系统用来存放root用户的个人数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;可以被解释为&lt;code&gt;served by your system&lt;/code&gt;。FHS允许&lt;code&gt;rsync&lt;/code&gt;，&lt;code&gt;ftp&lt;/code&gt;，&lt;code&gt;www&lt;/code&gt;等数据存放在改目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/media&lt;/td&gt;
&lt;td&gt;该目录通常被用来挂载可移除设备，如CD-ROM，U盘等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;根据FHS，该目录通常被用来作为短期的挂载点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/tmp&lt;/td&gt;
&lt;td&gt;该目录用来存放一些短期的文件，&lt;strong&gt;&lt;em&gt;不要再该目录下存放重要文件，该目录下的文件有可能会被系统回收&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;内存目录&#34;&gt;内存目录&lt;/h1&gt;

&lt;p&gt;Linux系统中，几乎所有的东西都被映射成文件，文件有的是对应着硬盘、设备（CD-ROM等）等，有的则被Linux映射到内存中。这一节介绍映射到内存中的目录。&lt;/p&gt;

&lt;h2 id=&#34;dev目录&#34;&gt;/dev目录&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/dev&lt;/code&gt;目录映射了各种设备文件，这些文件由系统启动的时候扫描硬件生成。&lt;/p&gt;

&lt;h3 id=&#34;物理设备文件&#34;&gt;物理设备文件&lt;/h3&gt;

&lt;p&gt;物理设备包括很多种，如硬盘，CD-ROM等。不同的物理设备映射为&lt;code&gt;/dev&lt;/code&gt;目录下不同的文件。如SATA/SCSI设备或USB通常被映射为&lt;code&gt;/dev/sd*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;可以为&lt;code&gt;[a-z]&lt;/code&gt;中的任意字符；而IDE设备通常被映射为&lt;code&gt;/dev/hd*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;为&lt;code&gt;[a-z]&lt;/code&gt;中任意字符。&lt;/p&gt;

&lt;h3 id=&#34;dev-tty跟-dev-pts&#34;&gt;/dev/tty跟/dev/pts&lt;/h3&gt;

&lt;p&gt;首先需要搞清楚&lt;code&gt;tty&lt;/code&gt;设备跟&lt;code&gt;pts&lt;/code&gt;设备的区别。这两者都是终端设备，所谓终端设备通常指的是能够接受命令输入，并可能同时能够输出的设备，但是这两者是有本质的不同的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;tty设备&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tty&lt;/code&gt;是&lt;code&gt;Teletype&lt;/code&gt;的简称，表示原生的终端设备，通常指的是物理终端设备如串口，键鼠接口等，以及系统内核模拟的终端设备。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;pts设备&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pts&lt;/code&gt;是&lt;code&gt;Pseudo Terminal Slave&lt;/code&gt;的简称，表示伪终端设备，通常由应用进程模拟出来，如ssh开启的终端等。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;tty&lt;/code&gt;设备通常被映射为&lt;code&gt;/dev/tty*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;代表数字，如&lt;code&gt;/dev/tty1&lt;/code&gt;等。而&lt;code&gt;pts&lt;/code&gt;设备被映射为&lt;code&gt;/dev/pts/*&lt;/code&gt;，其中&lt;code&gt;*&lt;/code&gt;表示数字，如&lt;code&gt;/dev/pts/1&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;dev-null&#34;&gt;/dev/null&lt;/h3&gt;

&lt;p&gt;该文件在Linux中有着特殊的意义，是一个只有输入的文件，且文件有无限的大小，你不能从该文件读出任何东西，任何写入的内容逻辑上相当于消失了。从实现的角度，实际上任何写入的内容都被系统丢弃了。&lt;/p&gt;

&lt;h2 id=&#34;proc目录&#34;&gt;/proc目录&lt;/h2&gt;

&lt;p&gt;该目录用来记录内核以及内核进程的实时信息，可以通过它轻而易举的实现对内核状态的获取甚至改变。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/proc/&lt;id&gt;&lt;/td&gt;
&lt;td&gt;几乎每个进程都会在该目录下有映射的文件&lt;code&gt;/proc/*&lt;/code&gt;，其中&lt;code&gt;&amp;lt;id&amp;gt;&lt;/code&gt;代表进程的ID。该目录记录的该进程的几乎所有的状态信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/cpuinfo&lt;/td&gt;
&lt;td&gt;记录了系统的CPU信息，通常通过该文件可以知道系统有多少个CPU（核数）。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/meminfo&lt;/td&gt;
&lt;td&gt;记录了系统的内存信息，可以通过它知道系统有多少内存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/sys&lt;/td&gt;
&lt;td&gt;在&lt;code&gt;/proc&lt;/code&gt;目录下的绝大部分文件都是只读的文件，但是在该目录下有些文件是可写的，可以通过它们改变内核状态&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/interrupts&lt;/td&gt;
&lt;td&gt;记录了当前系统的中断信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/proc/kcore&lt;/td&gt;
&lt;td&gt;这个文件代表了系统的物理内存，其大小就是物理内存的大小，因此千万不要用&lt;code&gt;cat&lt;/code&gt;来试图显示该文件内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;usr目录&#34;&gt;/usr目录&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;/usr&lt;/code&gt;目录估计是被误解最多的目录，一般大家都以为它是&lt;code&gt;user&lt;/code&gt;的简写，感觉应该存放的是用户相关的东西，但是实际上完全不是这样。它其实是&lt;code&gt;Unix System Resources&lt;/code&gt;的简写，表示Unix系统资源。通常情况下，该目录以只读的权限被挂载。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/usr/bin&lt;/td&gt;
&lt;td&gt;很多命令都存放在这个目录下面，事实上，在Centos跟Solaris系统中，&lt;code&gt;/bin&lt;/code&gt;目录实际上只是一个软连接，连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/include&lt;/td&gt;
&lt;td&gt;存放大量的头文件，可能会被C代码引用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/lib&lt;/td&gt;
&lt;td&gt;存放库文件，同样，在Centos跟Solaris系统中，&lt;code&gt;/lib&lt;/code&gt;其实就是软连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/lib64&lt;/td&gt;
&lt;td&gt;存放64位的库文件，在Centos中，&lt;code&gt;/lib64&lt;/code&gt;也是软连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/sbin&lt;/td&gt;
&lt;td&gt;很多daemon程序都是放在此目录下，在Centos中，&lt;code&gt;/sbin&lt;/code&gt;也是软连接到此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/local&lt;/td&gt;
&lt;td&gt;此目录通常用来安装一些本地的应用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/share&lt;/td&gt;
&lt;td&gt;此目录通常用来存放各种体系无关的数据。&lt;code&gt;/usr/share/man&lt;/code&gt;就是用来存放&lt;code&gt;man&lt;/code&gt;命令用到的帮助文档&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/src&lt;/td&gt;
&lt;td&gt;此目录通常存放内核的代码文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;var目录&#34;&gt;/var目录&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;/var&lt;/code&gt;目录用来存放可变的数据，如日志，数据库文件等。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/var/log&lt;/td&gt;
&lt;td&gt;此目录用来存放各种日志文件，包括系统跟应用的日志&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/log/messages&lt;/td&gt;
&lt;td&gt;在RedHat系列系统中，此文件用来记录系统刚刚发生的事情。在Debian和Ubuntu系统中，对应的文件是&lt;code&gt;/var/log/syslog&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/cache&lt;/td&gt;
&lt;td&gt;此目录存放很多应用的缓存数据，如&lt;code&gt;yum&lt;/code&gt;命令可能会缓存部分数据在此目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/spool&lt;/td&gt;
&lt;td&gt;一般情况下，该目录会存放邮件cron任务等数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/lib&lt;/td&gt;
&lt;td&gt;通常此目录下会存放应用的状态信息，如&lt;code&gt;/var/lib/mysql&lt;/code&gt;存放&lt;code&gt;mysql&lt;/code&gt;数据库，&lt;code&gt;/var/lib/docker&lt;/code&gt;存放&lt;code&gt;docker&lt;/code&gt;的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux系统介绍--综述</title>
      <link>https://keysaim.github.io/post/linux/2017-10-09-linux-study-overview/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-10-09-linux-study-overview/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;从大二（2006年）开始接触Linux到现在已经有10几年了，遥记得那时候Ubuntu还是个位数时代，现在都到17了，真的是光阴如梭啊。这这些年里面，Linux也有了长足的发展，是时候再次系统的对Linux进行重新学习了，所谓温故而知新，何况Linux本身也有很多新的变化。本系列博文将基于博主的&lt;a href=&#34;https://keysaim.github.io/2017/08/18/linux-learning-materials/&#34;&gt;这一篇&lt;/a&gt;博文中推荐的书籍为基础，结合一些网上的资料，对Linux进行一次系统的整理。希望通过此次整理能够使自己对Linux的理解更进一步，也希望能够给读者一定的参考。&lt;/p&gt;

&lt;h1 id=&#34;说明&#34;&gt;说明&lt;/h1&gt;

&lt;p&gt;本系列博文中各种例子都将基于Centos 7的Linux系统，可能与其它发行版本会有些许出入，还望读者留意。&lt;/p&gt;

&lt;h1 id=&#34;相关博文&#34;&gt;相关博文&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/10/09/linux-study-command-line/&#34;&gt;Linux系统介绍（一）命令行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/10/09/linux-study-file-system-hierarchy/&#34;&gt;Linux系统介绍（二）文件系统结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/10/10/linux-study-shell-basic/&#34;&gt;Linux系统介绍（三）shell基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/11/16/linux-study-io-pipe/&#34;&gt;Linux系统学习（四）IO重定向与管道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://keysaim.github.io/2017/11/17/linux-study-common-tools/&#34;&gt;Linux系统介绍（五）常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本系列博文将持续更新，并在此章节中进行统一整理。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何搭建本地的Git服务器</title>
      <link>https://keysaim.github.io/post/git/2017-09-04-how-to-setup-git-server/</link>
      <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/git/2017-09-04-how-to-setup-git-server/</guid>
      
        <description>

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;本文将介绍如何在本地搭建Git服务器。我们知道Git其实是个分布式的版本管理系统，与中心化的版本管理系统如SVN有根本的不同，每个使用者都可以在本地存储一份独立的备份，每个Git的使用者并不会因为没有中心服务器而不能工作（如果是SVN之类的，如果服务器挂了是不能够提交改动的）。然而，在进行团队开发的时候，有时候还是非常需要有一个统一的地方管理唯一的一份完整的代码，这样可以非常方便的进行团队协作开发。这里讲述一种极为简单的搭建本地Git服务器的方法。&lt;/p&gt;

&lt;h1 id=&#34;如何搭建&#34;&gt;如何搭建&lt;/h1&gt;

&lt;h2 id=&#34;准备一台linux服务器&#34;&gt;准备一台Linux服务器&lt;/h2&gt;

&lt;p&gt;这里不考虑windows系统，所以请务必准备一台Linux系统，分发版本没有关系，这里假定使用的是&lt;code&gt;Centos 7&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;配置git服务器&#34;&gt;配置Git服务器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo adduser git
$ sudo passwd git
Changing password for user git.
New password:
Retype new password:
passwd: all authentication tokens updated successfully.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置好ssh&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo su git
$ cd
$ mkdir .ssh &amp;amp;&amp;amp; chmod 700 .ssh
$ touch .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;初始化项目&#34;&gt;初始化项目&lt;/h2&gt;

&lt;p&gt;假定我们有一个叫&lt;code&gt;test&lt;/code&gt;的项目需要管理，那么首先我们需要在Git服务器上面创建并初始化该项目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ sudo su git
$ cd
$ mkdir test
$ cd test
$ git init --bare
Initialized empty Git repository in /home/git/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，其中&lt;code&gt;git init --bare&lt;/code&gt;就是用来初始化Git项目的，&lt;code&gt;--bare&lt;/code&gt;参数表示只存储Git的管理文件而不展现&lt;code&gt;test&lt;/code&gt;项目本身的文件。查看下初始化之后的目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ ls
branches  config  description  HEAD  hooks  info  objects  refs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见里面只有Git管理有关的文件。&lt;/p&gt;

&lt;h2 id=&#34;上传-test-项目&#34;&gt;上传&lt;code&gt;test&lt;/code&gt;项目&lt;/h2&gt;

&lt;p&gt;假定Git服务器IP为&lt;code&gt;10.10.10.10&lt;/code&gt;，回到你的工作机器，打开&lt;code&gt;test&lt;/code&gt;项目目录，上传项目：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ cd test
$ git remote add origin git@10.10.10.10:/home/git/mlc
$ git remote -v
origin  git@10.10.10.10:/home/git/mlc (fetch)
origin  git@10.10.10.10:/home/git/mlc (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果发现&lt;code&gt;git remote add origin&lt;/code&gt;执行失败：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote add origin git@10.10.10.10:/home/git/mlc
fatal: remote origin already exists.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明曾经已经设置过&lt;code&gt;origin&lt;/code&gt;地址了，可以更改如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git remote remove origin
$ git remote -v
$ git remote add origin git@10.10.10.10:/home/git/mlc
$ git remote -v
origin  git@10.10.10.10:/home/git/mlc (fetch)
origin  git@10.10.10.10:/home/git/mlc (push)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置好之后，可以上传&lt;code&gt;test&lt;/code&gt;项目了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git push origin master
git@10.10.10.10&#39;s password:
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 531 bytes | 0 bytes/s, done.
Total 4 (delta 0), reused 0 (delta 0)
To 10.10.10.10:/home/git/mlc
 * [new branch]      master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，Git服务器已经可以正常工作了。&lt;/p&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;本文只是简单的介绍原生的Git服务器的搭建，实际上，在现实工作中很多情况下都会有专门的基于Git的管理系统，使用起来非常方便。这里面非开源的最有名当然是&lt;code&gt;Github&lt;/code&gt;了，开源的里面目前最好的应该是&lt;code&gt;Gitlab&lt;/code&gt;了，参照官方文档，你可以非常方便的搭建自己的Git服务器了。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server&#34;&gt;Git on the Server - Setting Up the Server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Linux学习从入门到精通推荐书籍</title>
      <link>https://keysaim.github.io/post/linux/2017-08-18-linux-learning-materials/</link>
      <pubDate>Fri, 18 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/linux/2017-08-18-linux-learning-materials/</guid>
      
        <description>

&lt;h1 id=&#34;如何学习linux&#34;&gt;如何学习Linux&lt;/h1&gt;

&lt;p&gt;在现在的生活，生产，研究等领域，Linux已经无所不在，从我们使用的手机，车载设备，到服务器，桌面电脑等，Linux已经成为这个世界方方面面的基石。尤其对于参与技术有关工作的你学习Linux是必须的，那么，该如何有效的学习呢？Linux从诞生至今，已经是一个非常庞大且复杂的系统，下图是Linux系统代码行数的统计（参考&lt;a href=&#34;https://www.linuxcounter.net/statistics/kernel&#34;&gt;linuxcounter&lt;/a&gt;）：
&lt;img src=&#34;https://keysaim.github.io/img/blog-linux-code-lines.png&#34; alt=&#34;Linux代码行数变化&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见截止本文为止，Linux的代码行数逼近2千万行，你就每天看1万行也得要6，7年，况且这还只是Linux内核的代码量，再加上每个Linux发行版本有关的代码，估计得突破天际了。因此，要在短期内全面的学习Linux的方方面面对于一个正常的人来说几乎不太可能。所以，学习Linux的关键便在于对于学习Linux的目的一定要明确，通常来讲可能会涉及到一下方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;了解及入门&lt;/li&gt;
&lt;li&gt;成为Linux的系统管理员&lt;/li&gt;
&lt;li&gt;学习Linux应用编程&lt;/li&gt;
&lt;li&gt;学习Linux内核开发&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，这只是其中几个大的方面，即便如此，其中每个方面都是一个非常大的议题。比如说&lt;code&gt;学习Linux内核开发&lt;/code&gt;，这个就包括了无数小的方面，内核本身就包括了非常多的细分方向，比如有的搞网络，有的搞文件系统，有的搞驱动开发等等。所以，对于Linux，还请千万慎重的评价自己是否真的&lt;code&gt;精通&lt;/code&gt;，学无止境，真要&lt;code&gt;精通&lt;/code&gt;Linux的主要方面，有可能需要穷尽你的个人生涯。&lt;/p&gt;

&lt;p&gt;当然，对于学习Linux，前人已经铺好了无数的基石，有无数可以参考学习的资料，而且内核也是开源的，必要的时候可以查看&lt;a href=&#34;https://github.com/torvalds/linux&#34;&gt;其代码&lt;/a&gt;，甚至已经有非常多帮你分析内核代码的&lt;a href=&#34;https://www.quora.com/What-are-the-best-resources-to-learn-about-Linux-kernel-internals&#34;&gt;书籍资料&lt;/a&gt;，甚至还有很多&lt;a href=&#34;https://www.zhihu.com/question/19606660&#34;&gt;中文资料&lt;/a&gt;。所以，不论你打算要学习到如何的程度，已经有无数的资料可以参考，也有极为庞大的&lt;a href=&#34;http://www.linuxandubuntu.com/home/top-10-communities-to-help-you-learn-linux&#34;&gt;社区&lt;/a&gt;可以依靠。本文将就Linux学习推荐一些经典免费的书籍，主要侧重覆盖从入门到成为系统管理员的有关方面，学习对象为初学Linux，以及需要重新系统学习Linux的读者，将涵盖以下方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;入门基础&lt;/li&gt;
&lt;li&gt;Linux命令行及工具&lt;/li&gt;
&lt;li&gt;Linux Bash脚本&lt;/li&gt;
&lt;li&gt;Linux发行版本&lt;/li&gt;
&lt;li&gt;Linux系统管理&lt;/li&gt;
&lt;li&gt;Linux基本开发&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;为啥需要重点学习系统管理方面呢？有的Linux开发人员可能会说，不是有专门的Linux系统管理员吗，有必要花大力气学习系统管理吗？这个博主表示是非常有必要，开发可能侧重于功能的实现，而且往往侧重于细节，然而系统管理则直接面向功能本身，更多的是从整个系统的宏观角度来熟悉Linux。咱们有句话说&lt;code&gt;不识庐山真面目，只缘身在此山中&lt;/code&gt;便是这个道理，开发者对于细节或许极为了解，但是未必对整个系统功能有足够的熟悉。而如果对于宏观的系统整体有足够的理解，对于开发本身来说也是有很大的促进作用的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;书籍推荐&#34;&gt;书籍推荐&lt;/h1&gt;

&lt;h2 id=&#34;入门基础书籍&#34;&gt;入门基础书籍&lt;/h2&gt;

&lt;h3 id=&#34;introduction-to-linux&#34;&gt;Introduction to Linux&lt;/h3&gt;

&lt;p&gt;这是一本免费的书，来自于&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux文档项目&lt;/a&gt;。虽然免费，但是不影响它的流行程度，该书比较系统的介绍了Linux的一些基本概念，包括文件系统，命令行，网络等。但是鉴于Linux现在也是版本帝，有些内容可能跟不上最新的版本，但是，这完全不影响对于基本概念的理解。&lt;/p&gt;

&lt;h3 id=&#34;linux-fundamentals&#34;&gt;Linux Fundamentals&lt;/h3&gt;

&lt;p&gt;从这本书的书名就可以看出，作者&lt;a href=&#34;http://www.linkedin.com/in/cobbaut&#34;&gt;Paul Cobbaut&lt;/a&gt;就是侧重于介绍Linux最基础的有关知识。涉及到Linux的历史，如何安装以及一些简单但是常用的命令。&lt;/p&gt;

&lt;h2 id=&#34;linux命令行及工具书籍&#34;&gt;Linux命令行及工具书籍&lt;/h2&gt;

&lt;h3 id=&#34;gnu-linux-command-line-tools-summary&#34;&gt;GNU/Linux Command−Line Tools Summary&lt;/h3&gt;

&lt;p&gt;这本书同样来自于&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux文档项目&lt;/a&gt;。适于初学Linux命令行的读者。&lt;/p&gt;

&lt;h3 id=&#34;bash-reference-manual-from-gnu&#34;&gt;Bash Reference Manual from GNU&lt;/h3&gt;

&lt;p&gt;此书来自于&lt;a href=&#34;https://www.gnu.org/home.en.html&#34;&gt;GNU&lt;/a&gt;，着重介绍Linux命令行。&lt;/p&gt;

&lt;h3 id=&#34;the-linux-command-line&#34;&gt;The Linux Command Line&lt;/h3&gt;

&lt;p&gt;如果你把前面的几本基本的命令行的书籍啃完，并迫切希望能够进一步深入了解命令行，那么这本出自&lt;a href=&#34;http://www.oreilly.com/pub/au/4962&#34;&gt;William Shotts&lt;/a&gt;的书是必须一读的，此书500多页的篇幅，极为详尽的介绍了Linux命令行，也许你自诩比较熟悉命令行，相信此书还是能够带个你新的见识。&lt;/p&gt;

&lt;h2 id=&#34;linux-bash脚本书籍&#34;&gt;Linux Bash脚本书籍&lt;/h2&gt;

&lt;h3 id=&#34;bash-beginners-guide&#34;&gt;Bash Beginners Guide&lt;/h3&gt;

&lt;p&gt;顾名思义，此书就是为初学者准备的，同样来自于&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux文档项目&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;advanced-bash-scripting-guide&#34;&gt;Advanced Bash-Scripting Guide&lt;/h3&gt;

&lt;p&gt;如果你对Linux Bash脚本有了基本的认识，那么这本书将是你进阶的必备书籍。此书900多页的篇幅涉及Bash脚本的方方面面，不论对于打算进阶或者已经较为熟悉的人来说都是一本重要的参考书籍。&lt;/p&gt;

&lt;h3 id=&#34;the-awk-programming-language&#34;&gt;The AWK Programming Language&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.tutorialspoint.com/unix_commands/awk.htm&#34;&gt;AWK&lt;/a&gt;命令是一个极为强大的Linux命令，同时提供非常强大的脚本支持。也正是因为强大，所以就有专门的书籍来介绍这个命令，如果你要把自己的Linux命令再提升一点的话，建议看下这本书来深入的学习该命令。&lt;/p&gt;

&lt;h3 id=&#34;linux-101-hacks&#34;&gt;Linux 101 Hacks&lt;/h3&gt;

&lt;p&gt;不论从这本书的书名，还是这本书的来源&lt;a href=&#34;http://www.thegeekstuff.com/2009/02/linux-101-hacks-download-free-ebook/&#34;&gt;The Geek Stuff&lt;/a&gt;，此书都暗示着其将以新颖独特的角度为你介绍Linux脚本。&lt;/p&gt;

&lt;h2 id=&#34;linux发行版本书籍&#34;&gt;Linux发行版本书籍&lt;/h2&gt;

&lt;h3 id=&#34;centos-system-administration-essentials&#34;&gt;CentOS System Administration Essentials&lt;/h3&gt;

&lt;p&gt;这本书较为系统的介绍了Centos系统的有关知识，包括了文件系统，包管理系统，用户系统，安全中心以及一些常用应用软件介绍，对于使用Centos系统的人员还是有所帮助的。&lt;/p&gt;

&lt;h3 id=&#34;ubuntu-manual&#34;&gt;Ubuntu Manual&lt;/h3&gt;

&lt;p&gt;这本书来源于&lt;a href=&#34;https://ubuntu-manual.org/&#34;&gt;Ubuntu Manual网站&lt;/a&gt;，以不多的篇幅较为系统的介绍了Ubuntu系统的日常使用。&lt;/p&gt;

&lt;h3 id=&#34;for-linux-mint-just-tell-me-damnit&#34;&gt;For Linux Mint: Just Tell Me Damnit!&lt;/h3&gt;

&lt;p&gt;这本书集中介绍了&lt;a href=&#34;https://www.linuxmint.com/&#34;&gt;Linux Mint&lt;/a&gt;系统，涉及了安装，包管理，定制桌面等方面。&lt;/p&gt;

&lt;h3 id=&#34;solus-linux-manual&#34;&gt;Solus Linux Manual&lt;/h3&gt;

&lt;p&gt;顾名思义，此书介绍&lt;a href=&#34;https://solus-project.com/&#34;&gt;Solus Linux&lt;/a&gt;系统，篇幅较短。&lt;/p&gt;

&lt;h3 id=&#34;the-debian-administration-s-handbook&#34;&gt;The Debian Administration’s Handbook&lt;/h3&gt;

&lt;p&gt;这本书号称&lt;a href=&#34;https://www.debian.org/&#34;&gt;Debian Linux&lt;/a&gt;系统的圣经，涵盖了Debian的历史，安装，包管理，虚拟机，存储等方面，对于使用Debian系统的人员来说，此书必备。&lt;/p&gt;

&lt;h2 id=&#34;linux系统管理书籍&#34;&gt;Linux系统管理书籍&lt;/h2&gt;

&lt;p&gt;虽然此章节被独立命名为&lt;code&gt;Linux系统管理&lt;/code&gt;，但是，前面的章节其实都可以认为在此范畴，只不过更加偏向于基础。所以，在这章节中都是侧重于较为深入的系统管理有关知识，最好是在前面章节的基础之上再学习此章节。&lt;/p&gt;

&lt;h3 id=&#34;linux-system-administration&#34;&gt;Linux System Administration&lt;/h3&gt;

&lt;p&gt;这本书也是出自于&lt;a href=&#34;http://www.linkedin.com/in/cobbaut&#34;&gt;Paul Cobbaut&lt;/a&gt;之手，覆盖了网络，磁盘，用户，内核，库等管理。&lt;/p&gt;

&lt;h3 id=&#34;advanced-linux-system-administration&#34;&gt;Advanced Linux System Administration&lt;/h3&gt;

&lt;p&gt;如果你觉得自己很懂Linux系统管理，也非常希望别人能够知道你很懂，那么你应该去参加&lt;a href=&#34;LPIC&#34;&gt;LPIC&lt;/a&gt;。而要参加该认证，此书是必看的官方指定用书。&lt;/p&gt;

&lt;h3 id=&#34;pro-linux-system-administration-2nd-edition&#34;&gt;Pro Linux System Administration, 2nd Edition&lt;/h3&gt;

&lt;p&gt;这是一本非常详细的Linux系统管理的书籍，全书1000+页的篇幅涵盖了Linux系统管理的很多方面，即适合初学者，也可以作为有一定基础的人系统学习的重要参考。同时，该书的第二部分介绍了很多Linux系统管理的应用，如NTP，DNS，邮件，文件共享，性能监控等等，非常值得一看。&lt;/p&gt;

&lt;h3 id=&#34;linux-bible-9th-edition&#34;&gt;Linux Bible 9th Edition&lt;/h3&gt;

&lt;p&gt;不用讲了，敢取这么牛逼的名字，而且书的&lt;a href=&#34;https://www.amazon.com/Linux-Bible-Christopher-Negus/dp/1118999878&#34;&gt;评价还不错&lt;/a&gt;，必然是好书。此书将近1000页的篇幅，从不同程度介绍了Linux系统，比如如何入门，如何成为Linux的熟练用户，如果成为系统管理员，如何成为Linux安全维护人员等等，还是比较实至名归的。&lt;/p&gt;

&lt;h3 id=&#34;linux-servers&#34;&gt;Linux Servers&lt;/h3&gt;

&lt;p&gt;此书又来自于&lt;a href=&#34;http://www.linkedin.com/in/cobbaut&#34;&gt;Paul Cobbaut&lt;/a&gt;，从书名就能推测其范畴，主要侧重讲述如何打造你的Linux服务器，包括web server，mysql数据库，DHCP等。&lt;/p&gt;

&lt;h3 id=&#34;linux-networking&#34;&gt;Linux Networking&lt;/h3&gt;

&lt;p&gt;Linux网络对于系统管理员来说是最为重要的一块之一，同样出自于&lt;code&gt;Paul Cobbaut&lt;/code&gt;之手，较为系统的介绍了Linux网络基础知识，网络配置，同时着重介绍了常用的网络服务等。&lt;/p&gt;

&lt;h3 id=&#34;linux-storage&#34;&gt;Linux Storage&lt;/h3&gt;

&lt;p&gt;此书作者估计你都能猜到了，不错，又是&lt;code&gt;Paul Cobbaut&lt;/code&gt;。该书同样较为系统的介绍了Linux的存储系统，涉及文件管理，磁盘管理，数据库等方面。&lt;/p&gt;

&lt;h3 id=&#34;linux-security&#34;&gt;Linux Security&lt;/h3&gt;

&lt;p&gt;作者就不介绍了，你懂的。很多时候对于Linux系统都更侧重于功能方面，对于安全方面往往做的不够。然而现在网络安全正面临越来越严峻的挑战，由网络安全带来的损失也是越来越大，因此，对于Linux的安全管理已经成为系统管理最为重要的一部分。此书同样系统的介绍了Linux的安全管理有关方面，涉及用户/组安全，文件安全，iptables防火墙，selinux安全等方面。&lt;/p&gt;

&lt;h2 id=&#34;linux基本开发书籍&#34;&gt;Linux基本开发书籍&lt;/h2&gt;

&lt;p&gt;最后，稍微推荐一下Linux开发有关的书籍。&lt;/p&gt;

&lt;h3 id=&#34;advanced-linux-programming&#34;&gt;Advanced Linux Programming&lt;/h3&gt;

&lt;p&gt;此书面向致力于Linux软件开发人员，介绍了Linux多进程，多线程，进程间通信，以及硬件接口等方面，对于从事有关开发工作还是很有帮助的。&lt;/p&gt;

&lt;h1 id=&#34;书籍下载&#34;&gt;书籍下载&lt;/h1&gt;

&lt;p&gt;本博文中所列书籍都可以在博主的&lt;a href=&#34;http://download.csdn.net/user/walkerhau&#34;&gt;CSDN个人下载空间&lt;/a&gt;找到，资源名为&lt;code&gt;Linux入门及系统管理推荐书籍&lt;/code&gt;，由于大小限制，分为三个压缩包，下载所有压缩包到一台Linux机器，解压运行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat linux-basic.tgz.* | tar xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中有一个文件整理的时候出错了，文件名为&lt;code&gt;Ubuntu-Manual.pdf&lt;/code&gt;，其实是&lt;code&gt;Solus&lt;/code&gt;的电子书。你可以从&lt;a href=&#34;https://ubuntu-manual.org/&#34;&gt;Ubuntu Manual官网&lt;/a&gt;直接下载。&lt;/p&gt;

&lt;p&gt;资源需要一定的资源分下载，本来想免费，但是博主个人觉得还是不错的资源，也废了自己不少时间整理，鉴于免费容易轻视，所以面向真要打算认真学习的人，收取一定的资源分。如果没有足够的资源分也没关系，你完全可以根据本文所列书名Google之，都是有免费电子版的。实在不愿自己搜罗的，也可以在评论区留下你的邮箱，博主会不定时发给你邮箱，压缩包总共将近140M，还请确保你的邮箱能够接收如此大的附件。&lt;/p&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;Linux博大精深，很多人即便从事一辈子Linux开发也未必能够熟悉Linux的各个方面。为了能够支撑自己在Linux的路上走的足够远，一个牢固的基础是必须得有的，本文侧重推荐Linux系统管理的有关书籍，希望读者能够对Linux的宏观整体有个非常透彻的理解，为以后选择某个方向深入研究铺好路。同时，也欢迎各位的其它推荐，欢迎在评论区留言，有合适的书籍，博主也会不定时更新在博文之中。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;Linux_Doc_Proj&#34;&gt;Linux Document Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ubuntu-manual.org/&#34;&gt;Ubuntu Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;LPIC&#34;&gt;LPIC wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itsfoss.com/learn-linux-for-free/&#34;&gt;learn linux for free&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>如何给自己的博客网站加入评论系统</title>
      <link>https://keysaim.github.io/post/blog/2017-08-16-how-to-add-comments/</link>
      <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://keysaim.github.io/post/blog/2017-08-16-how-to-add-comments/</guid>
      
        <description>

&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;在&lt;a href=&#34;https://keysaim.github.io/2017/08/15/how-to-setup-your-github-io-blog/&#34;&gt;这一篇&lt;/a&gt;博文中，咱们介绍了如何快速的搭建个人的博客网站，但是这个博客网站是基于&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;的纯静态网站，自身是不带任何的可交互的元素的，自然也就没有评论系统。但是，对于一个好的博客网站，如果没有评论系统，那基本上就属于自娱自乐了，也违背了博客分享的精神。因此，本文将着重介绍如何快速的给自己的博客网站加入评论系统。&lt;/p&gt;

&lt;h1 id=&#34;评论系统介绍&#34;&gt;评论系统介绍&lt;/h1&gt;

&lt;p&gt;所谓评论系统，相信对于关注博客的你来说肯定不陌生。通常来讲有两大类，一类是网站自己提供评论系统，这个在很多较大的博客平台比较常见；一类是基于第三方的评论系统，这个在个人博客网站较为常见。对于个人博客，由于很多都是简单的托管在其他平台上面，比如博主网站托管于Github，因此很多都基本上是静态的网站，自身是没法提供评论系统。也正因为如此，也就催生了非常多的第三方的评论系统。这些系统国外比较有名的是&lt;a href=&#34;https://disqus.com/&#34;&gt;Disqus&lt;/a&gt;，国内更加五花八门了。国外的由于天朝特殊的网络环境，并不十分稳定，所以对于国内的博客网站来说，通常都会选择国内的第三方评论系统。至于国内的评论系统有哪些选择呢，建议参考&lt;a href=&#34;https://www.mokeyjay.com/archives/1732&#34;&gt;这篇博文&lt;/a&gt;。总的来说，由于评论系统这个东东，目前还没有明显的盈利的地方，倒闭关门是很有可能的，因此尽量选择大公司为后台的吧。&lt;/p&gt;

&lt;p&gt;最近在研究评论系统的时候，偶然发现&lt;a href=&#34;http://hydroecology.net/using-github-to-host-blog-comments/&#34;&gt;有人&lt;/a&gt;居然直接使用Github的Issue系统来做评价系统，顿时眼前一亮啊。鉴于咱们的博客便是基于Github的，如果可行，那简直绝配了。于是博主就开始疯狂的搜索有关现状，Github都多少年了，博主深信应该已经有人造过轮子了。这类轮子肯定是属于前端方面的，于是在&lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;网站上面搜索，果然&lt;a href=&#34;https://www.npmjs.com/search?q=github%20issue%20comment&amp;amp;page=1&amp;amp;ranking=popularity&#34;&gt;发现不少&lt;/a&gt;。比较下来，发现一款国人开发的&lt;a href=&#34;https://www.npmjs.com/package/gitment&#34;&gt;gitment&lt;/a&gt;最为完整。这也就本文要介绍的评论系统了，本博客网站在可见的未来将采用该评论系统，这里对作者的分享表示感谢。&lt;/p&gt;

&lt;h1 id=&#34;gitment使用&#34;&gt;gitment使用&lt;/h1&gt;

&lt;p&gt;gitment的使用在&lt;a href=&#34;https://imsun.net/posts/gitment-introduction/&#34;&gt;官网&lt;/a&gt;有较为详细的介绍，步骤写的还是比较清楚的。这里只是对于讲述可能踩到的坑：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;请务必不要使用你的&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;这个repo作为&lt;code&gt;gitment&lt;/code&gt;的repo&lt;/p&gt;

&lt;p&gt;可能这个repo作为Github特殊的repo，使用它作为&lt;code&gt;gitment&lt;/code&gt;的repo时，总是不能够认证成功。建议再创建一个专门用来存放评论的repo。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/settings/applications/new&#34;&gt;生成oauth授权&lt;/a&gt;的时候，请务必确保&lt;code&gt;Authorization callback URL&lt;/code&gt;是你的博客网站，如博主的是&lt;code&gt;https://keysaim.github.io&lt;/code&gt;。否则会授权失败。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每次提交博文的时候，请务必记得初始化改博文的评论，否则读者无法进行评论&lt;/p&gt;

&lt;p&gt;所谓初始化其实就是在你的博文下面用自己的Github账号登陆之后，会出现一个&lt;code&gt;Initialize Comments&lt;/code&gt;字样的按钮，点击该按钮完成初始化。改初始化其实就是在你的Github repo里面针对这篇博文生成一个新的Issue。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;gitment&lt;/code&gt;之类的评论系统是基于Github的Issue系统，每篇博文都对应于你的Github repo里面的一个Issue，博文里面的评论其实都是在改Issue里面的评论，因此，你是有绝对权限对所有评论进行管理的。另外，由于&lt;code&gt;gitment&lt;/code&gt;项目开始不久，并且貌似作者比较忙，因此功能性，质量方面还是存在不足，当你使用过程中如果遇到任何问题，可以直接去&lt;a href=&#34;https://github.com/imsun/gitment&#34;&gt;gitment repo&lt;/a&gt;里面查看一下是不是别人也碰到类似问题。可能的情况下，你也可以提交自己的解决方案。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>